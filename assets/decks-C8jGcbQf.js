import{W as b,c as l,D as j,b as I}from"./index-BOsLoRk8.js";import{d as f,l as y}from"./db-CSQ4qy-K.js";function u(t){return Math.floor(Math.random()*16**t).toString(16).padStart(t,"0")}function P(){try{return crypto.randomUUID()}catch{return[u(8),u(4),u(4),u(4),`${u(6)}${u(6)}`].join("-")}}function N(t){return t!=null}async function m(t,e,r,a){const s=t.objectStore("cards"),o=await s.get(e),i=new Date;if(o){if(o.decks.includes(a.name)){let c=!1;const d=o.deckPositions.find(w=>w.deck===a.name);if(!d||(d.priority!==a.priority&&(d.priority=a.priority,c=!0),d.order!==r&&(d.order=r,c=!0),!c))return}else o.decks.push(a.name),o.deckPositions.push({deck:a.name,priority:a.priority,order:r});let n=Number.POSITIVE_INFINITY,p=Number.POSITIVE_INFINITY;for(const c of o.deckPositions)c.priority<n?(n=c.priority,p=c.order):c.priority===n&&c.order<p&&(p=c.order);o.position.priority=n,o.position.order=p,o.updatedAt=i,await s.put(o)}else{await s.add({id:e,value:String.fromCodePoint(e),types:["kanji-read","kanji-write"],decks:[a.name],position:{priority:a.priority,order:r},deckPositions:[{deck:a.name,priority:a.priority,order:r}],createdAt:i});const n=t.objectStore("progress");await n.add({cardId:e,cardType:"kanji-write",fsrs:I()}),await n.add({cardId:e,cardType:"kanji-read",fsrs:I()})}}async function k(t,e){let r=0;for(const a of e.cards)r+=1,await m(t,a,r,e)}async function T(t,e,r){const a=t.objectStore("cards");let s=0;for(const o of r.cards)s+=1,await m(t,o,s,r);for(const o of e.cards)if(!r.cards.includes(o)){const i=await a.get(o);i&&(S(i,r.name),await a.put(i))}}function S(t,e){const r=t.decks.indexOf(e);r!==-1&&t.decks.splice(r,1);const a=t.deckPositions.findIndex(o=>o.deck===e);if(a===-1)return;const[s]=t.deckPositions.splice(a,1);if(s.priority===t.position.priority&&s.order===t.position.order){let o=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY;for(const n of t.deckPositions)n.priority<o&&(o=n.priority,i=n.order);t.position.priority=o,t.position.order=i}t.updatedAt=new Date}async function g(t,e){const r=t.objectStore("cards").index("decks").iterate(IDBKeyRange.only(e));for await(const a of r){const s=a.value;S(a.value,e),await a.update(s)}}async function x(t,e){let r=!1;e||(r=!0,e=(await f).transaction(["cards","decks","progress"],"readwrite"));const a=e.objectStore("decks"),s=await a.get(t);if(!s)throw new Error("Deck does not exist");return s.active||(await a.put({...s,active:!0,updatedAt:new Date}),await k(e,s),r&&(await e.done,y.postMessage("deck-added"))),s}async function O(t,e){const r=new Date,a=await Promise.all(e.map(async({name:i,label:n,priority:p,content:c})=>{if(await(await f).getKey("decks",i))return i;const v=(await(await fetch(c)).text()).split(`
`).map(D=>D.codePointAt(0)).filter(N);return{name:i,label:n,priority:p,category:t,cards:v,active:!0}})),s=(await f).transaction(["cards","decks","progress"],"readwrite"),o=s.objectStore("decks");for(const i of a){let n;typeof i=="string"?n=await x(i,s):(n={...i,createdAt:r},await o.add(n)),await k(s,n)}await s.done,y.postMessage("deck-category-added")}async function A(t){const e=(await f).transaction(["cards","decks"],"readwrite"),r=e.objectStore("decks"),a=await r.get(t);!a||!a.active||(await r.put({...a,active:!1,updatedAt:new Date}),await g(e,t),await e.done,y.postMessage("deck-removed"))}async function E(t){const e=(await f).transaction(["cards","decks"],"readwrite"),r=await e.objectStore("decks").index("category").getAllKeys(t);for(const a of r)await A(a);await e.done}async function F(t,e=new b(j())){const r=(await f).transaction(["cards","progress"]),a=r.objectStore("cards"),s=r.objectStore("progress"),o={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},i=new Date,n=a.index("decks").iterate(IDBKeyRange.only(t));for await(const p of n)for(const[c,d]of Object.entries(o)){const w=await s.get([p.primaryKey,c]);w&&(w.fsrs.state===l.New?d.new+=1:w.fsrs.state===l.Learning||w.fsrs.state===l.Relearning||w.fsrs.due<i?d.due+=1:e.get_retrievability(w.fsrs,i,!1)>.99?d.know+=1:d.review+=1)}return o}async function K({name:t=`custom/${P()}`,active:e=!0,createdAt:r=new Date,...a}){const s={...a,name:t,active:e,createdAt:r},o=(await f).transaction(["decks","cards","progress"],"readwrite");return await o.objectStore("decks").add(s),await k(o,s),await o.done,y.postMessage("deck-created"),s}async function _(t){const e=(await f).transaction(["decks","cards","progress"],"readwrite"),r=e.objectStore("decks"),a=await r.get(t.name);a?await r.put({...t,updatedAt:new Date}):await r.add(t),a!=null&&a.active?t.active?await T(e,a,t):await g(e,t.name):t.active&&await k(e,t),await e.done,y.postMessage("custom-deck-edited")}async function B(t){const e=(await f).transaction(["decks","cards"],"readwrite");await e.objectStore("decks").delete(t),await g(e,t),await e.done,y.postMessage("custom-deck-removed")}export{x as a,O as b,K as c,A as d,_ as e,E as f,F as g,B as r};
