{"version":3,"file":"component-picker.worker-BeQQggMa.js","sources":["../node_modules/yta/src/extras/pipe.js","../node_modules/yta/src/sync/combinators/zip.js","../node_modules/yta/src/sync/consumers/group-by.js","../node_modules/yta/src/sync/consumers/to-array.js","../node_modules/yta/src/sync/generators/range.js","../node_modules/yta/src/sync/operators/enumerate.js","../src/workers/component-picker.worker.ts"],"sourcesContent":["/* eslint-disable jsdoc/reject-any-type */\n/**\n * @typedef {(a: any) => any} AnyFn\n */\n/* eslint-enable jsdoc/reject-any-type */\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @template Ts\n * @typedef {Ts extends [...infer _, infer T] ? T : never} Last\n */\n/* eslint-enable jsdoc/valid-types */\n\n/**\n * Create a pipeline for chaining iterator with operators.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { drop, filter, map, range, reduce, take } from \"yta/sync\";\n *\n * pipe(\n *   range(),\n *   drop(10),\n *   filter((x) => x % 2 === 0),\n *   map((x) => x * 2),\n *   take(5),\n *   reduce((sum, x) => sum + x, 0),\n * );\n * // => 140\n * ```\n *\n * @template Source\n * @overload\n * @param {Source} source\n * @returns {Source}\n */\n/**\n * @template Source\n * @template A\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @returns {A}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @returns {B}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @returns {C}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @returns {D}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @returns {E}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @returns {F}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @template G\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @param {(f: G) => G} fnG\n * @returns {G}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @template G\n * @template H\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @param {(f: G) => G} fnG\n * @param {(g: G) => H} fnH\n * @returns {H}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @template G\n * @template H\n * @template I\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @param {(f: G) => G} fnG\n * @param {(g: G) => H} fnH\n * @param {(h: H) => I} fnI\n * @returns {I}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @template G\n * @template H\n * @template I\n * @template J\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @param {(f: G) => G} fnG\n * @param {(g: G) => H} fnH\n * @param {(h: H) => I} fnI\n * @param {(i: I) => J} fnJ\n * @returns {J}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @template G\n * @template H\n * @template I\n * @template J\n * @template K\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @param {(f: G) => G} fnG\n * @param {(g: G) => H} fnH\n * @param {(h: H) => I} fnI\n * @param {(i: I) => J} fnJ\n * @param {(j: J) => K} fnK\n * @returns {K}\n */\n/**\n * @template Source\n * @template A\n * @template B\n * @template C\n * @template D\n * @template E\n * @template F\n * @template G\n * @template H\n * @template I\n * @template J\n * @template K\n * @template L\n * @overload\n * @param {Source} source\n * @param {(source: Source) => A} fnA\n * @param {(a: A) => B} fnB\n * @param {(b: B) => C} fnC\n * @param {(c: C) => D} fnD\n * @param {(d: D) => E} fnE\n * @param {(e: E) => F} fnF\n * @param {(f: G) => G} fnG\n * @param {(g: G) => H} fnH\n * @param {(h: H) => I} fnI\n * @param {(i: I) => J} fnJ\n * @param {(j: J) => K} fnK\n * @param {(k: K) => L} fnL\n * @returns {L}\n */\n/**\n * @template Source\n * @template {AnyFn[]} Fns\n * @param {Source} source\n * @param {AnyFn[]} fns\n * @returns {ReturnType<Last<Fns>>}\n */\nexport default function pipe(source, ...fns) {\n  // @ts-ignore\n  return fns.reduce((value, fn) => fn(value), source);\n}\n","/**\n * Take any number of iterators, and zip them together into one iterator of\n * tuples. Closes after the shortest of the inputs closes.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { flatRepeat, of, range, toArray, zip } from \"yta/sync\";\n *\n * pipe(\n *   zip(\n *     of(\"a\", \"b\", \"c\"),\n *     range(),\n *     flatRepeat(() => of(true, false)),\n *   ),\n *   toArray(),\n * );\n * // => [[\"a\", 0, true], [\"b\", 1, false], [\"c\", 2, true]]\n * ```\n *\n * If you want to zip an iterator of iterators in a pipeline you can use them\n * spread opperator.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { flatRepeat, of, range, toArray, zip } from \"yta/sync\";\n *\n * pipe(\n *   of(\n *     of(\"a\", \"b\", \"c\"),\n *     range(),\n *     flatRepeat(() => of(true, false)),\n *   ),\n *   (iterables) => zip(...iterables),\n *   toArray(),\n * );\n * // => [[\"a\", 0, true], [\"b\", 1, false], [\"c\", 2, true]]\n * ```\n *\n * **See also:**\n *\n * - {@link zipLongest}\n *\n * @template {unknown[]} A - Tuple type with item type of each input iterator\n * @param {{ [K in keyof A]: Iterable<A[K]> }} items - The iterators to be zipped\n * @returns {Generator<A, void>}\n */\nexport default function* zip(...items) {\n  const iters = items.map((item) => item[Symbol.iterator]());\n\n  try {\n    let results = iters.map((iter) => iter.next());\n\n    while (!results.some(({ done }) => done)) {\n      yield /** @type {A} */ (results.map(({ value }) => value));\n\n      results = iters.map((iter) => iter.next());\n    }\n  } finally {\n    iters.forEach((iter) => {\n      if (typeof iter.return === \"function\") {\n        iter.return();\n      }\n    });\n  }\n}\n","/**\n * Collect the items of the iterator into a map of arrays keyed by the return\n * value of your key generator function.\n *\n * Optionally pass a map function which will map the inner values.\n *\n * Note we return a `Map` which natively implements `Symbol.iterator` which\n * means you are free to chain another operator after itâ€™s consumed.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { group-by, of } from \"yta/sync\";\n *\n * pipe(\n *   of(\n *     { name: \"foo\", value: 5 },\n *     { name: \"foo\", value: 42 },\n *     { name: \"bar\", value: 101 },\n *     { name: \"foo\", value: 13 },\n *     { name: \"bar\", value: 2 },\n *   ),\n *   groupBy(\n *     ({ name }) => name,\n *     ({ value }) => value,\n *   ),\n *   Object.fromEntries,\n * );\n * // => { \"foo\": [5, 42, 13], \"bar\": [101, 2] }\n * ```\n *\n * **See also:**\n *\n * [The native `Map` object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n *\n * @template A\n * @template K\n * @template [B=A]\n * @param {(item: A) => K} getKey\n * @param {(item: A) => B} [mapFn]\n * @returns {(items: Iterable<A>) => Map<K, B[]>}\n */\nexport default function groupBy(getKey, mapFn) {\n  return (items) => {\n    /** @type {Map<K, B[]>} */\n    const map = new Map();\n\n    for (const item of items) {\n      const key = getKey(item);\n      let values = map.get(key);\n\n      if (!values) {\n        values = [];\n        map.set(key, values);\n      }\n\n      values.push(/** @type {B} */ (mapFn ? mapFn(item) : item));\n    }\n\n    return map;\n  };\n}\n","/**\n * Collect the iterator into an array.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { range, toArray } from \"yta/sync\";\n *\n * pipe(range(5), toArray());\n * // => [0, 1, 2, 3, 4]\n * ```\n *\n * @template A\n * @returns {(items: Iterable<A>) => A[]}\n */\nexport default function toArray() {\n  return (items) => [...items];\n}\n","/**\n * Generate a sequence of numbers between `start` and `stop` (start inclusive;\n * stop non-inclusive). If `stop` is not specified generate `start` many\n * number starting at 0. If `start` is not specified generate an infinitly long\n * sequences starting at 0.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { range, take, toArray } from \"yta/sync\";\n *\n * pipe(range(), take(5), toArray());\n * // => [0, 1, 2, 3, 4]\n *\n * [...range(5)];\n * // => [0, 1, 2, 3, 4]\n *\n * [...range(10, 13)];\n * // => [10, 11, 12]\n *\n * [...range(42, 50, 3)];\n * // => [42, 45, 48]\n *\n * [...range(15, 10, -1)];\n * // => [15, 14, 13, 12, 11]\n * ```\n *\n * @param {number} [start] - The starting number (inclusive) or sequence length\n *     if `stop` is not specified\n * @param {number} [stop] - The stopping number (non-inclusive)\n * @param {number} [step] - The step increment.\n * @returns {Generator<number, void>}\n */\nexport default function* range(start, stop, step = 1) {\n  let begin = start;\n  let end = stop;\n\n  if (typeof begin === \"undefined\") {\n    end = Number.POSITIVE_INFINITY;\n    begin = 0;\n  }\n\n  if (typeof end === \"undefined\") {\n    end = begin;\n    begin = 0;\n  }\n\n  /** @type {(a: number, b: number) => boolean} */\n  const cmp = begin <= end ? (a, b) => a < b : (a, b) => b < a;\n\n  for (let i = begin; cmp(i, end); i += step) {\n    yield i;\n  }\n}\n","import { range, zip } from \"../index.js\";\n\n/**\n * Map the iterator into enumerated pairs.\n *\n * ```js\n * import { pipe } from \"yta\";\n * import { enumerate, of, toArray } from \"yta/sync\";\n *\n * pipe(of(\"a\", \"b\", \"c\"), enumerate(), toArray());\n * // => [[0, \"a\"], [1, \"b\"], [2, \"c\"]]\n * ```\n *\n * @template A The item type\n * @returns {(items: Iterable<A>) => Generator<[number, A], void>}\n */\nexport default function enumerate() {\n  return (items) => zip(range(), items);\n}\n","import { pipe } from \"yta\";\nimport { enumerate, groupBy, toArray } from \"yta/sync\";\n\nconst UNIT_SEP = \"\\u{241f}\";\nconst RECORD_SEP = \"\\u{241e}\";\n\ntype AllRadicalsMessage = {\n  type: \"all-radicals\";\n  allRadicals: Map<number, string[]>;\n};\n\ntype KanjiSelectionMessage = {\n  type: \"kanji-selection\";\n  kanjiSelection: Map<number, string[]>;\n  filteredRadicals: Set<string>;\n};\n\nexport type ComponentPickerMessage = AllRadicalsMessage | KanjiSelectionMessage;\n\nconst fetchingKanjiRadicals = fetch(\"/data/index/kanji-radicals-v1.usv\").then(\n  (response) => response.text(),\n);\n\nconst fetchingRadicalsKanji = fetch(\"/data/index/radicals-kanji-v1.usv\").then(\n  (response) => response.text(),\n);\n\nfunction* readUSVRecords(source: string): Iterable<Iterable<string>> {\n  const charIter = source[Symbol.iterator]();\n\n  let pos = 0;\n  let result = charIter.next();\n\n  function advanceCharIter() {\n    result = charIter.next();\n  }\n\n  function* unitIter() {\n    let unitStart = pos;\n\n    if (result.value === \"\\n\") {\n      // Ignore record leading newline.\n      pos += 1;\n      unitStart = pos;\n      result = charIter.next();\n    }\n\n    while (!result.done) {\n      const char = result.value;\n\n      if (char === RECORD_SEP) {\n        pos += char.length;\n\n        return;\n      }\n\n      if (char === UNIT_SEP) {\n        yield source.slice(unitStart, pos);\n\n        unitStart = pos + char.length;\n      }\n\n      pos += char.length;\n      advanceCharIter();\n    }\n  }\n\n  while (!result.done) {\n    yield unitIter();\n\n    advanceCharIter();\n  }\n}\n\nasync function createRadicalSelection() {\n  const source = await fetchingRadicalsKanji;\n  const radicalsMap = new Map<number, string[]>();\n\n  for (const record of readUSVRecords(source)) {\n    let literal = \"\";\n    for (const [unitNumber, unit] of pipe(record, enumerate())) {\n      if (unitNumber === 0) {\n        literal = unit;\n      } else if (unitNumber === 1) {\n        const strokeCount = Number.parseInt(unit);\n        let literals = radicalsMap.get(strokeCount);\n\n        if (!literals) {\n          literals = [];\n          radicalsMap.set(strokeCount, literals);\n        }\n\n        literals.push(literal);\n      }\n    }\n  }\n\n  return radicalsMap;\n}\n\nasync function findKanji(radicals: Set<string>): Promise<Set<string>> {\n  let found: Set<string> | null = null;\n\n  if (radicals.size === 0) {\n    return new Set();\n  }\n\n  let foundCount = 0;\n  let literal = null;\n\n  recordLoop: for (const record of readUSVRecords(\n    await fetchingRadicalsKanji,\n  )) {\n    for (const [unitNumber, unit] of pipe(record, enumerate())) {\n      switch (unitNumber) {\n        case 0:\n          if (radicals.has(unit)) {\n            literal = unit;\n            foundCount += 1;\n          } else {\n            literal = null;\n          }\n\n          break;\n\n        case 2:\n          if (literal) {\n            if (found) {\n              const intersection = new Set<string>();\n              for (const char of unit) {\n                if (found.has(char)) {\n                  intersection.add(char);\n                }\n              }\n              found = intersection;\n            } else {\n              found = new Set();\n              for (const char of unit) {\n                found.add(char);\n              }\n            }\n\n            if (foundCount === radicals.size) {\n              break recordLoop;\n            }\n          }\n      }\n    }\n  }\n\n  return found ?? new Set();\n}\n\nasync function getStrokesAndRadicals(\n  kanji: Set<string>,\n): Promise<[Map<string, number>, Set<string>]> {\n  const strokeCounts = new Map<string, number>();\n  const radicals = new Set<string>();\n\n  let foundCount = 0;\n  let literal = null;\n\n  recordLoop: for (const record of readUSVRecords(\n    await fetchingKanjiRadicals,\n  )) {\n    for (const [unitNumber, unit] of pipe(record, enumerate())) {\n      switch (unitNumber) {\n        case 0:\n          if (kanji.has(unit)) {\n            literal = unit;\n            foundCount += 1;\n          } else {\n            literal = null;\n          }\n\n          break;\n\n        case 1:\n          if (literal) {\n            strokeCounts.set(literal, Number.parseInt(unit));\n          }\n\n          break;\n\n        case 2:\n          if (literal) {\n            for (const char of unit) {\n              radicals.add(char);\n            }\n\n            if (foundCount === kanji.size) {\n              break recordLoop;\n            }\n          }\n      }\n    }\n  }\n\n  return [strokeCounts, radicals];\n}\n\naddEventListener(\n  \"message\",\n  async (event: MessageEvent<\"init\" | Set<string>>) => {\n    if (event.data === \"init\") {\n      const allRadicals = await createRadicalSelection();\n      const message: AllRadicalsMessage = {\n        type: \"all-radicals\",\n        allRadicals,\n      };\n\n      self.postMessage(message);\n\n      return;\n    }\n\n    const foundKanji = await findKanji(event.data);\n    const [kanjiStrokeCounts, filteredRadicals] =\n      await getStrokesAndRadicals(foundKanji);\n\n    const kanjiSelection = pipe(\n      foundKanji,\n      groupBy((literal) => kanjiStrokeCounts.get(literal) ?? NaN),\n      toArray(),\n      (array) => new Map(array.sort(([a], [b]) => a - b)),\n    );\n\n    const message: KanjiSelectionMessage = {\n      type: \"kanji-selection\",\n      kanjiSelection,\n      filteredRadicals,\n    };\n\n    self.postMessage(message);\n  },\n);\n"],"names":["pipe","source","fns","value","fn","zip","items","iters","item","results","iter","done","groupBy","getKey","mapFn","map","key","values","toArray","range","start","stop","step","begin","end","cmp","a","b","i","enumerate","UNIT_SEP","RECORD_SEP","fetchingKanjiRadicals","response","fetchingRadicalsKanji","readUSVRecords","charIter","pos","result","advanceCharIter","unitIter","unitStart","char","createRadicalSelection","radicalsMap","record","literal","unitNumber","unit","strokeCount","literals","findKanji","radicals","found","foundCount","recordLoop","intersection","getStrokesAndRadicals","kanji","strokeCounts","event","message","foundKanji","kanjiStrokeCounts","filteredRadicals","array"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}