import{d as V,c as g,p as X,o as d,f as Z,w as M,b as _,t as D,u as p,q as ee,s as te,_ as O,m as ne,n as ae,a as v,g as f,F as j,h,j as re,e as T,R as oe,r as se,v as ie,x as ue}from"./index-CjZvuqUe.js";import{d as c,l as ce,u as L,a as we}from"./db-B6qaO1xm.js";import{m as x,H as le,E as S}from"./time-B3so-xG4.js";import{u as i,A as de}from"./index-HJmKARl4.js";import{f as N,c as k,t as F}from"./iterators-PeFxZeGd.js";import{u as P}from"./index-MwAREZqo.js";const A=P("shodoku.app.preferences.limit.due",50),Q=P("shodoku.app.preferences.limit.new",10);async function me(t={new:Q.value,due:A.value}){return await(await c).add("review-limits",{time:new Date,count:t}),ce.postMessage("review-limit-increased")}const ve={class:"card-value"},fe=V({__name:"ReviewSummaryItem",props:{cardId:{},reviews:{}},setup(t){const n=t,e=g(()=>String.fromCharCode(n.cardId)),a=g(()=>n.reviews.at(0)),r=g(()=>a.value?a.value.log.state===i.New:!1);return(u,s)=>{const o=X("RouterLink");return d(),Z(o,{to:p(ee)(e.value),class:te(["review-summary-item",{"is-new":r.value}])},{default:M(()=>[_("strong",ve,D(e.value),1)]),_:1},8,["to","class"])}}}),pe=O(fe,[["__scopeId","data-v-15bfc4b2"]]),ge={class:"review-summary"},ye={key:0},Ce={class:"review-count total-count"},Re={class:"review-count new-count"},Ie={key:1,class:"review-summary-list"},xe=V({__name:"ReviewSummary",setup(t){const n=ne(),e=ae(),{result:a}=L(async()=>{const s=new Map,o=(await c).transaction("reviews").store.index("review");for await(const w of o.iterate(IDBKeyRange.lowerBound(x()))){const l=w.value;let m=s.get(l.cardId);m||(m=[],s.set(l.cardId,m)),m.push(l)}return s}),r=g(()=>{if(!a.value)return 0;let s=0;for(const[o]of a.value.values())o.log.state===i.New&&(s+=1);return s});function u(){me(),n.name!==oe&&e.push(se)}return(s,o)=>(d(),v("section",ge,[p(a)?(d(),v("p",ye,[o[3]||(o[3]=f(" Reviewed ")),_("span",Ce,D(p(a).size)+" cards",1),o[4]||(o[4]=f(" today")),r.value>0?(d(),v(j,{key:0},[o[1]||(o[1]=f(" (of which ")),_("span",Re,D(r.value)+" new",1),o[2]||(o[2]=f(")"))],64)):h("",!0),o[5]||(o[5]=f(". "))])):h("",!0),p(a)?(d(),v("ul",Ie,[(d(!0),v(j,null,re(p(a),([w,l])=>(d(),v("li",null,[T(pe,{"card-id":w,reviews:l},null,8,["card-id","reviews"])]))),256))])):h("",!0),o[7]||(o[7]=_("p",null," Click the button below to temporarily increase your daily review limit. ",-1)),T(de,{onClick:o[0]||(o[0]=w=>u())},{default:M(()=>o[6]||(o[6]=[f("Continue Review")])),_:1})]))}}),Be=O(xe,[["__scopeId","data-v-e028f67f"]]);async function*b(t){const n=new Set;let e=await(await c).transaction("progress").store.index("state+due").openCursor();for(;e;){const[a,r]=e.key;if(a<i.Learning){e=await e.continue([i.Learning,S]);continue}if(a>i.Learning&&a<i.Relearning){e=await e.continue([i.Relearning,S]);continue}if(!t||r<t){const[u]=e.primaryKey;n.has(u)||(yield e,n.add(u))}e=await e.continue()}}async function Y(){const t=new Set,n=(await c).transaction("reviews").store.index("review").iterate(IDBKeyRange.lowerBound(x()));for await(const e of n)t.add(e.value.cardId);return t}let y=null;async function $(){const t=new Date,n=(await c).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([i.New,x()],[i.New,t],!0,!0));return n.then(e=>{y=e}),n}async function*q(){const t=await Y(),n=(await c).transaction(["cards","progress"],"readwrite"),e=n.objectStore("cards"),a=n.objectStore("progress").index("cardId+cardType+state");let r=await e.index("position").openKeyCursor(IDBKeyRange.bound([0,0],[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],!1,!0));for(;r;){if(t.has(r.primaryKey)){r=await r.continue();continue}let u=await a.openCursor([r.primaryKey,"kanji-write",i.New]);u||(u=await a.openCursor([r.primaryKey,"kanji-read",i.New])),u&&(yield u),r=await r.continue()}}let C=null;async function z(){const t=new Date,n=(await c).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([i.Review,x()],[i.Review,t],!1,!0));return n.then(e=>{C=e}),n}async function*H(){const t=new Date,n=await Y(),e=(await c).transaction(["cards","progress","reviews"],"readonly"),a=e.objectStore("cards"),r=e.objectStore("progress"),u=IDBKeyRange.bound([i.Review,S],[i.Review,t],!1,!0);let s=await r.index("state+due").openCursor(u);for(;s;){const[o]=s.primaryKey;if(!n.has(o)){const w=await a.get(o);w&&w.position.priority<Number.POSITIVE_INFINITY&&(yield s)}s=await s.continue()}}async function U(){const t=await(await c).getAllFromIndex("review-limits","time",IDBKeyRange.lowerBound(x())),n={due:0,new:0};for(const{count:e}of t)n.due+=e.due,n.new+=e.new;return n}let R=null;async function W(t=0){const n=await $(),e=Math.max(0,Q.value+t-n),a=k(F(e,q()));return a.then(r=>{R=r}),a}let I=null;async function G(t=0){const n=await z(),e=Math.max(0,A.value+t-n),a=k(F(e,H()));return a.then(r=>{I=r}),a}async function Ne(){const t=await N(b(new Date));if(t)return t.value;const n=await U(),e=R??await W(n.new),a=y??await $(),r=I??await G(n.due),u=C??await z(),s=e+a,o=r+u,w=e+r,l=Math.ceil((s+o)/s),m=Math.floor(l/2);if(e>0&&(r===0||w%l===m)){const K=await N(q());if(K)return K.value}const B=await N(H());if(B)return B.value;const E=await N(b());return E?E.value:null}async function _e(){const t=await U();return{new:await W(t.new),due:await G(t.due),learning:await k(b())}}async function Ee({cardId:t,cardType:n,fsrs:e},a){const r=(await c).transaction(["progress","reviews"],"readwrite"),u=r.objectStore("progress"),s=r.objectStore("reviews");e.state===i.New?(R!==null&&(R-=1),y!==null&&(y+=1)):e.state===i.Review&&(I!==null&&(I-=1),C!==null&&(C+=1)),await u.put({cardId:t,cardType:n,fsrs:a.card}),await s.add({cardId:t,cardType:n,log:a.log})}function J(){C=null,I=null,y=null,R=null}globalThis.setInterval(J,le);we.addEventListener("message",t=>{t.data==="review-limit-increased"&&J()});function Ke(t){const n=g(()=>{const e=ue(t);if(e){const{cardId:a,cardType:r}=e;return async()=>(await c).get("progress",[a,r])}return Ne});return L(n)}function je(){const{result:t,error:n}=L(_e);return ie(()=>{n.value&&console.error(n.value)}),t}export{Be as R,Ke as a,Ee as r,je as u};
