import{u as i}from"./index-guFvHVik.js";import{E as f,m as g}from"./time-BmRGZSiE.js";import{d as c,u as m}from"./db-CvDPecAE.js";import{g as L,l as I,m as j}from"./index-C9kKT1ht.js";async function y(e){let t=0;for await(const n of await e)t+=1;return t}async function d(e){for await(const t of await e)return t}async function*x(e,t){let n=0;for await(const a of t){if(n>=e)return;yield a,n+=1}}const E=10,M=50;async function*l(e){const t=new Set;let n=await(await c).transaction("progress").store.index("state+due").openCursor();for(;n;){const[a,r]=n.key;if(a<i.Learning){n=await n.continue([i.Learning,f]);continue}if(a>i.Learning&&a<i.Relearning){n=await n.continue([i.Relearning,f]);continue}if(!e||r<e){const[o]=n.primaryKey;t.has(o)||(yield n,t.add(o))}n=await n.continue()}}async function D(){const e=new Set,t=(await c).transaction("reviews").store.index("review").iterate(IDBKeyRange.lowerBound(g()));for await(const n of t)e.add(n.value.cardId);return e}async function R(){const e=new Date;return(await c).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([i.New,g()],[i.New,e],!0,!0))}async function*S(){const e=await D(),t=(await c).transaction(["cards","progress"],"readwrite"),n=t.objectStore("cards"),a=t.objectStore("progress").index("cardId+cardType+state");let r=await n.index("position").openKeyCursor();for(;r;){if(e.has(r.primaryKey)){r=await r.continue();continue}let o=await a.openCursor([r.primaryKey,"kanji-write",i.New]);o||(o=await a.openCursor([r.primaryKey,"kanji-read",i.New])),o&&(yield o),r=await r.continue()}}async function h(){const e=new Date;return(await c).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([i.Review,g()],[i.Review,e],!1,!0))}async function*N(){const e=new Date,t=await D(),n=(await c).transaction(["cards","progress","reviews"],"readonly"),a=n.objectStore("cards"),r=n.objectStore("progress"),o=IDBKeyRange.bound([i.Review,f],[i.Review,e],!1,!0);let s=await r.index("state+due").openCursor(o);for(;s;){const[u]=s.primaryKey;if(!t.has(u)){const w=await a.get(u);w&&w.position.priority<Number.POSITIVE_INFINITY&&(yield s)}s=await s.continue()}}async function b(){const e=await R(),t=Math.max(0,E-e);return y(x(t,S()))}async function K(){const e=await h(),t=Math.max(0,M-e);return y(x(t,N()))}async function T(){const e=await d(l(new Date));if(e)return e.value;const t=await b(),n=await R(),a=await K(),r=await h(),o=t+n,s=a+r,u=Math.ceil((o+s)/o),w=Math.floor(u/2);if(t>0&&(a===0||a%u===w)){const p=await d(S());if(p)return p.value}const v=await d(N());if(v)return v.value;const C=await d(l());return C?C.value:null}async function k(){return{new:await b(),due:await K(),learning:await y(l())}}async function V(e,t,n){const a=(await c).transaction(["progress","reviews"],"readwrite"),r=a.objectStore("progress"),o=a.objectStore("reviews");await r.put({cardId:e,cardType:t,fsrs:n.card}),await o.add({cardId:e,cardType:t,log:n.log})}function W(e){const t=L(()=>{const r=j(e);if(r){const{cardId:o,cardType:s}=r;return async()=>(await c).get("progress",[o,s])}return T}),{value:n,error:a}=m(t);return I(()=>{a.value&&console.error(a.value)}),n}function q(){const{value:e,error:t}=m(k);return I(()=>{t.value&&console.error(t.value)}),e}export{W as a,V as r,q as u};
