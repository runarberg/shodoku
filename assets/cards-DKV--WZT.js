import{u as i}from"./index-guFvHVik.js";import{E as f,m as l}from"./time-BmRGZSiE.js";import{d as s,u as I}from"./db-D-7ArWxb.js";import{g as K,s as T,v as E}from"./index-PWB7_iI1.js";async function y(e){let t=0;for await(const n of await e)t+=1;return t}async function d(e){for await(const t of await e)return t}async function*m(e,t){let n=0;for await(const a of t){if(n>=e)return;yield a,n+=1}}const L=10,j=50;async function*g(e){const t=new Set;let n=await(await s).transaction("progress").store.index("state+due").openCursor();for(;n;){const[a,r]=n.key;if(a<i.Learning){n=await n.continue([i.Learning,f]);continue}if(a>i.Learning&&a<i.Relearning){n=await n.continue([i.Relearning,f]);continue}if(!e||r<e){const[o]=n.primaryKey;t.has(o)||(yield n,t.add(o))}n=await n.continue()}}async function x(){const e=new Set,t=(await s).transaction("reviews").store.index("review").iterate(IDBKeyRange.lowerBound(l()));for await(const n of t)e.add(n.value.cardId);return e}async function D(){const e=new Date;return(await s).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([i.New,l()],[i.New,e],!0,!0))}async function*N(){const e=await x(),t=(await s).transaction(["cards","progress"],"readwrite"),n=t.objectStore("cards"),a=t.objectStore("progress").index("cardId+cardType+state");let r=await n.index("position").openKeyCursor(IDBKeyRange.bound([0,0],[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],!1,!0));for(;r;){if(e.has(r.primaryKey)){r=await r.continue();continue}let o=await a.openCursor([r.primaryKey,"kanji-write",i.New]);o||(o=await a.openCursor([r.primaryKey,"kanji-read",i.New])),o&&(yield o),r=await r.continue()}}async function R(){const e=new Date;return(await s).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([i.Review,l()],[i.Review,e],!1,!0))}async function*S(){const e=new Date,t=await x(),n=(await s).transaction(["cards","progress","reviews"],"readonly"),a=n.objectStore("cards"),r=n.objectStore("progress"),o=IDBKeyRange.bound([i.Review,f],[i.Review,e],!1,!0);let c=await r.index("state+due").openCursor(o);for(;c;){const[u]=c.primaryKey;if(!t.has(u)){const w=await a.get(u);w&&w.position.priority<Number.POSITIVE_INFINITY&&(yield c)}c=await c.continue()}}async function b(){const e=await D(),t=Math.max(0,L-e);return y(m(t,N()))}async function h(){const e=await R(),t=Math.max(0,j-e);return y(m(t,S()))}async function M(){const e=await d(g(new Date));if(e)return e.value;const t=await b(),n=await D(),a=await h(),r=await R(),o=t+n,c=a+r,u=Math.ceil((o+c)/o),w=Math.floor(u/2);if(t>0&&(a===0||a%u===w)){const v=await d(N());if(v)return v.value}const C=await d(S());if(C)return C.value;const p=await d(g());return p?p.value:null}async function _(){return{new:await b(),due:await h(),learning:await y(g())}}async function k(e,t,n){const a=(await s).transaction(["progress","reviews"],"readwrite"),r=a.objectStore("progress"),o=a.objectStore("reviews");await r.put({cardId:e,cardType:t,fsrs:n.card}),await o.add({cardId:e,cardType:t,log:n.log})}function F(e){const t=K(()=>{const n=E(e);if(n){const{cardId:a,cardType:r}=n;return async()=>(await s).get("progress",[a,r])}return M});return I(t)}function Y(){const{result:e,error:t}=I(_);return T(()=>{t.value&&console.error(t.value)}),e}export{F as a,k as r,Y as u};
