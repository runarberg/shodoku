import{d as p,l as y,u as l}from"./db-1SYsvhON.js";import{b as w,O as j,g as v,w as k}from"./reviews-D4EEJ0cN.js";import{u as x}from"./fsrs-CLWAx46U.js";import{c as g,B as m}from"./index-chiovaS4.js";function D(e){return e!=null}async function b(e,o,r,i,t){const s=await e.get(r);if(s){if(s.decks.includes(t.name))return;s.decks.push(t.name),s.deckPositions.push({deck:t.name,priority:t.priority,order:i}),t.priority===s.position.priority?s.position.order=Math.min(i,s.position.order):t.priority<s.position.priority&&(s.position.priority=t.priority,s.position.order=i),await e.put(s)}else await e.add({id:r,value:String.fromCodePoint(r),types:["kanji-read","kanji-write"],decks:[t.name],position:{priority:t.priority,order:i},deckPositions:[{deck:t.name,priority:t.priority,order:i}]}),await o.add({cardId:r,cardType:"kanji-write",fsrs:k()}),await o.add({cardId:r,cardType:"kanji-read",fsrs:k()})}async function R(e){const o=(await p).transaction(["cards","decks","progress"],"readwrite");await o.objectStore("decks").add(e);const i=o.objectStore("cards"),t=o.objectStore("progress");let s=0;for(const a of e.cards)s+=1,await b(i,t,a,s,e);await o.done,y.postMessage("deck-added")}async function V(e,o){const r=await(await p).getAllKeysFromIndex("decks","category",e),i=await Promise.all(o.filter(({name:n})=>!r.includes(n)).map(async({name:n,label:f,priority:c,content:d})=>{const S=(await(await fetch(d)).text()).split(`
`).map(I=>I.codePointAt(0)).filter(D);return{name:n,label:f,priority:c,category:e,cards:S}})),t=(await p).transaction(["cards","decks","progress"],"readwrite"),s=t.objectStore("decks"),a=t.objectStore("cards"),u=t.objectStore("progress");for(const n of i){await s.add(n);let f=0;for(const c of n.cards)f+=1,await b(a,u,c,f,n)}await t.done,y.postMessage("deck-category-added")}function P(e,o){const r=e.decks.indexOf(o);r!==-1&&e.decks.splice(r,1);const i=e.deckPositions.findIndex(t=>t.deck===o);if(i!==-1){const[t]=e.deckPositions.splice(i,1);if(t.priority===e.position.priority&&t.order===e.position.order){let s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const u of e.deckPositions)u.priority<s&&(s=u.priority,a=u.order);e.position.priority=s,e.position.order=a}}}async function N(e){const o=(await p).transaction(["cards","decks"],"readwrite"),r=o.objectStore("decks"),i=o.objectStore("cards");await r.delete(e);const t=i.index("decks").iterate(IDBKeyRange.only(e));for await(const s of t){const a=s.value;P(s.value,e),s.update(a)}await o.done,y.postMessage("deck-removed")}async function B(e){const o=(await p).transaction(["cards","decks"],"readwrite"),r=await o.objectStore("decks").index("category").getAllKeys(e);for(const i of r)await N(i);await o.done}async function T(e,o=new j(v())){const r=(await p).transaction(["cards","progress"]),i=r.objectStore("cards"),t=r.objectStore("progress"),s={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},a=new Date,u=i.index("decks").iterate(IDBKeyRange.only(e));for await(const n of u)for(const[f,c]of Object.entries(s)){const d=await t.get([n.primaryKey,f]);d&&(d.fsrs.state===w.New?c.new+=1:d.fsrs.state===w.Learning||d.fsrs.state===w.Relearning||d.fsrs.due<a?c.due+=1:o.get_retrievability(d.fsrs,a,!1)>.99?c.know+=1:c.review+=1)}return s}function M(e){const o=g(()=>{const i=m(e);return async()=>(await p).get("decks",i)}),{result:r}=l(o);return r}function _(){return l(async()=>(await p).transaction("decks").store.index("category+priority").getAll()).result}function q(e){const o=x(),r=g(()=>{const t=m(e);return()=>T(t,o.value)}),{result:i}=l(r);return i}export{_ as a,M as b,R as c,N as d,V as e,B as f,q as u};
