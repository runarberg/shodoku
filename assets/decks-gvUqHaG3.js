import{F as v,g as k,k as j,e as b,W as x,S as m,h as M,j as A}from"./reviews-C0tp5JDi.js";import{d,l as w}from"./db-CmzCis4b.js";function p(e){return Math.floor(Math.random()*16**e).toString(16).padStart(e,"0")}function C(){try{return crypto.randomUUID()}catch{return[p(8),p(4),p(4),p(4),`${p(6)}${p(6)}`].join("-")}}function T(e){return e!=null}async function y(e,t,a){const r=e.objectStore("cards"),o=e.objectStore("progress"),s=new Date;if(!await r.getKey(t)){const c={id:t,value:String.fromCodePoint(t),types:a,createdAt:s};r.add(c);for(const n of a)o.add({cardId:t,cardType:n,fsrs:A()});k([{store:"cards",op:"add",key:t},...a.map(n=>({store:"progress",op:"add",key:[t,n]}))])}}async function h(e,t){let a=t,r=!1;a||(r=!0,a=(await d).transaction(["cards","decks","progress"],"readwrite"));const o=a.objectStore("decks"),s=await o.get(e);if(!s)throw new Error("Deck does not exist");if(s.active)return s;const c=new Date;await o.put({...s,active:!0,updatedAt:c});for(const n of s.cards)y(a,n,["kanji-write","kanji-read"]);return k([{store:"decks",key:s.name,op:"put"}]),r&&(await a.done,w.postMessage("deck-added")),s}async function N(e,t){const a=new Date,r=await Promise.all(t.map(async({name:c,label:n,priority:u,content:g})=>{if(await(await d).getKey("decks",c))return c;const S=(await(await fetch(g)).text()).split(`
`).map(D=>D.codePointAt(0)).filter(T);return{name:c,label:n,priority:u,category:e,cards:S,cardTypes:["kanji-write","kanji-read"],active:!0}})),o=(await d).transaction(["cards","decks","progress"],"readwrite"),s=o.objectStore("decks");for(const c of r)if(typeof c=="string")h(c,o);else{const n={...c,createdAt:a};await s.add(n),k([{store:"decks",op:"add",key:n.name}]);for(const u of n.cards)y(o,u,["kanji-write","kanji-read"])}await o.done,w.postMessage("deck-category-added")}async function I(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e);if(!r||!r.active)return;const o=new Date;await a.put({...r,active:!1,updatedAt:o}),k([{store:"decks",op:"put",key:r.name}]),await t.done,w.postMessage("deck-removed")}async function R(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=await t.objectStore("decks").index("category").getAllKeys(e);for(const r of a)await I(r);await t.done}function P(){return{new:0,due:0,review:0,know:0}}async function W(e,t=new v(M())){const a=(await d).transaction(["decks","progress"]),r=a.objectStore("progress"),o=new Date,s=await a.objectStore("decks").get(e);if(!s)return null;const c=j.value/100,n=new Date(Date.now()+b.value*x),u=new Map(s.cardTypes.map(g=>[g,P()]));for await(const g of s.cards)for(const l of s.cardTypes){const i=await r.get([g,l]);if(!i)continue;const f=u.get(l);f&&(i.fsrs.state===m.New?f.new+=1:i.fsrs.state===m.Learning||i.fsrs.state===m.Relearning||i.fsrs.due<o?f.due+=1:i.fsrs.due>n&&t.get_retrievability(i.fsrs,o,!1)>c?f.know+=1:f.review+=1)}return u}async function $({name:e=`custom/${C()}`,active:t=!0,category:a="custom",createdAt:r=new Date,...o}){const s={...o,name:e,active:t,category:a,createdAt:r},c=(await d).transaction(["decks","cards","progress"],"readwrite");await c.objectStore("decks").add(s),k([{store:"decks",op:"add",key:s.name}]);for(const n of s.cards)y(c,n,o.cardTypes);return await c.done,w.postMessage("deck-created"),s}async function B(e){const t=(await d).transaction(["decks","cards","progress"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e.name);if(!r){await a.add(e),k([{store:"decks",op:"add",key:e.name}]),w.postMessage("deck-created");return}const o=new Date;await a.put({...e,updatedAt:o}),k([{store:"decks",op:"put",key:e.name}]);for(const s of e.cards)r.cards.includes(s)||y(t,s,["kanji-write","kanji-read"]);await t.done,w.postMessage("custom-deck-edited")}async function F(e){await(await d).transaction(["decks","cards"],"readwrite").objectStore("decks").delete(e),k([{store:"decks",op:"delete",key:e}]),w.postMessage("custom-deck-removed")}export{h as a,N as b,$ as c,I as d,B as e,R as f,W as g,F as r};
//# sourceMappingURL=decks-gvUqHaG3.js.map
