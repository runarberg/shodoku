import{u as l}from"./index-guFvHVik.js";import{E,m as O}from"./time-BmRGZSiE.js";import{d as m,l as ie,u as B}from"./db-xPPCzUcI.js";import{u as oe,s as se,v as V,l as W,x as ue,m as P,y as ce,z as le,A as fe,B as de,g as we,C as pe,D as ge}from"./index-DfymEPXH.js";async function A(e){let n=0;for await(const t of await e)n+=1;return n}async function D(e){for await(const n of await e)return n}async function*z(e,n){let t=0;for await(const r of n){if(t>=e)return;yield r,t+=1}}function ye(e){return ce()?(le(e),!0):!1}function j(e){return typeof e=="function"?e():oe(e)}const me=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const ve=Object.prototype.toString,Se=e=>ve.call(e)==="[object Object]",he=()=>{};function Ce(e,n){function t(...r){return new Promise((a,o)=>{Promise.resolve(e(()=>n.apply(this,r),{fn:n,thisArg:this,args:r})).then(a).catch(o)})}return t}const J=e=>e();function be(e=J){const n=W(!0);function t(){n.value=!1}function r(){n.value=!0}const a=(...o)=>{n.value&&e(...o)};return{isActive:ue(n),pause:t,resume:r,eventFilter:a}}function Ie(e){return fe()}function De(e,n,t={}){const{eventFilter:r=J,...a}=t;return P(e,Ce(r,n),a)}function Ne(e,n,t={}){const{eventFilter:r,...a}=t,{eventFilter:o,pause:s,resume:p,isActive:g}=be(r);return{stop:De(e,n,{...a,eventFilter:o}),pause:s,resume:p,isActive:g}}function xe(e,n=!0,t){Ie()?se(e,t):n?e():V(e)}const R=me?window:void 0;function Re(e){var n;const t=j(e);return(n=t==null?void 0:t.$el)!=null?n:t}function K(...e){let n,t,r,a;if(typeof e[0]=="string"||Array.isArray(e[0])?([t,r,a]=e,n=R):[n,t,r,a]=e,!n)return he;Array.isArray(t)||(t=[t]),Array.isArray(r)||(r=[r]);const o=[],s=()=>{o.forEach(f=>f()),o.length=0},p=(f,u,v,d)=>(f.addEventListener(u,v,d),()=>f.removeEventListener(u,v,d)),g=P(()=>[Re(n),j(a)],([f,u])=>{if(s(),!f)return;const v=Se(u)?{...u}:u;o.push(...t.flatMap(d=>r.map(b=>p(f,d,b,v))))},{immediate:!0,flush:"post"}),y=()=>{g(),s()};return ye(y),y}const N=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},x="__vueuse_ssr_handlers__",Oe=Ee();function Ee(){return x in N||(N[x]=N[x]||{}),N[x]}function Le(e,n){return Oe[e]||n}function Ae(e){return e==null?"any":e instanceof Set?"set":e instanceof Map?"map":e instanceof Date?"date":typeof e=="boolean"?"boolean":typeof e=="string"?"string":typeof e=="object"?"object":Number.isNaN(e)?"any":"number"}const je={boolean:{read:e=>e==="true",write:e=>String(e)},object:{read:e=>JSON.parse(e),write:e=>JSON.stringify(e)},number:{read:e=>Number.parseFloat(e),write:e=>String(e)},any:{read:e=>e,write:e=>String(e)},string:{read:e=>e,write:e=>String(e)},map:{read:e=>new Map(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e.entries()))},set:{read:e=>new Set(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e))},date:{read:e=>new Date(e),write:e=>e.toISOString()}},M="vueuse-storage";function Fe(e,n,t,r={}){var a;const{flush:o="pre",deep:s=!0,listenToStorageChanges:p=!0,writeDefaults:g=!0,mergeDefaults:y=!1,shallow:f,window:u=R,eventFilter:v,onError:d=i=>{console.error(i)},initOnMounted:b}=r,S=(f?de:W)(typeof n=="function"?n():n);if(!t)try{t=Le("getDefaultStorage",()=>{var i;return(i=R)==null?void 0:i.localStorage})()}catch(i){d(i)}if(!t)return S;const h=j(n),F=Ae(h),C=(a=r.serializer)!=null?a:je[F],{pause:te,resume:T}=Ne(S,()=>ne(S.value),{flush:o,deep:s,eventFilter:v});u&&p&&xe(()=>{t instanceof Storage?K(u,"storage",I):K(u,M,ae),b&&I()}),b||I();function _(i,c){if(u){const w={key:e,oldValue:i,newValue:c,storageArea:t};u.dispatchEvent(t instanceof Storage?new StorageEvent("storage",w):new CustomEvent(M,{detail:w}))}}function ne(i){try{const c=t.getItem(e);if(i==null)_(c,null),t.removeItem(e);else{const w=C.write(i);c!==w&&(t.setItem(e,w),_(c,w))}}catch(c){d(c)}}function re(i){const c=i?i.newValue:t.getItem(e);if(c==null)return g&&h!=null&&t.setItem(e,C.write(h)),h;if(!i&&y){const w=C.read(c);return typeof y=="function"?y(w,h):F==="object"&&!Array.isArray(w)?{...h,...w}:w}else return typeof c!="string"?c:C.read(c)}function I(i){if(!(i&&i.storageArea!==t)){if(i&&i.key==null){S.value=h;return}if(!(i&&i.key!==e)){te();try{(i==null?void 0:i.newValue)!==C.write(S.value)&&(S.value=re(i))}catch(c){d(c)}finally{i?V(T):T()}}}}function ae(i){I(i.detail)}return S}function k(e,n,t={}){const{window:r=R}=t;return Fe(e,n,r==null?void 0:r.localStorage,t)}const Y=k("shodoku.app.preferences.limit.due",50),G=k("shodoku.app.preferences.limit.new",10);async function We(e={new:G.value,due:Y.value}){return await(await m).add("review-limits",{time:new Date,count:e}),ie.postMessage("review-limit-increased")}async function*L(e){const n=new Set;let t=await(await m).transaction("progress").store.index("state+due").openCursor();for(;t;){const[r,a]=t.key;if(r<l.Learning){t=await t.continue([l.Learning,E]);continue}if(r>l.Learning&&r<l.Relearning){t=await t.continue([l.Relearning,E]);continue}if(!e||a<e){const[o]=t.primaryKey;n.has(o)||(yield t,n.add(o))}t=await t.continue()}}async function H(){const e=new Set,n=(await m).transaction("reviews").store.index("review").iterate(IDBKeyRange.lowerBound(O()));for await(const t of n)e.add(t.value.cardId);return e}async function Q(){const e=new Date;return(await m).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([l.New,O()],[l.New,e],!0,!0))}async function*$(){const e=await H(),n=(await m).transaction(["cards","progress"],"readwrite"),t=n.objectStore("cards"),r=n.objectStore("progress").index("cardId+cardType+state");let a=await t.index("position").openKeyCursor(IDBKeyRange.bound([0,0],[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],!1,!0));for(;a;){if(e.has(a.primaryKey)){a=await a.continue();continue}let o=await r.openCursor([a.primaryKey,"kanji-write",l.New]);o||(o=await r.openCursor([a.primaryKey,"kanji-read",l.New])),o&&(yield o),a=await a.continue()}}async function q(){const e=new Date;return(await m).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([l.Review,O()],[l.Review,e],!1,!0))}async function*U(){const e=new Date,n=await H(),t=(await m).transaction(["cards","progress","reviews"],"readonly"),r=t.objectStore("cards"),a=t.objectStore("progress"),o=IDBKeyRange.bound([l.Review,E],[l.Review,e],!1,!0);let s=await a.index("state+due").openCursor(o);for(;s;){const[p]=s.primaryKey;if(!n.has(p)){const g=await r.get(p);g&&g.position.priority<Number.POSITIVE_INFINITY&&(yield s)}s=await s.continue()}}async function X(){const e=await(await m).getAllFromIndex("review-limits","time",IDBKeyRange.lowerBound(O())),n={due:0,new:0};for(const{count:t}of e)n.due+=t.due,n.new+=t.new;return n}async function Z(e=0){const n=await Q(),t=Math.max(0,G.value+e-n);return A(z(t,$()))}async function ee(e=0){const n=await q(),t=Math.max(0,Y.value+e-n);return A(z(t,U()))}async function Te(){const e=await D(L(new Date));if(e)return e.value;const n=await X(),t=await Z(n.new),r=await Q(),a=await ee(n.due),o=await q(),s=t+r,p=a+o,g=t+a,y=Math.ceil((s+p)/s),f=Math.floor(y/2);if(t>0&&(a===0||g%y===f)){const d=await D($());if(d)return d.value}const u=await D(U());if(u)return u.value;const v=await D(L());return v?v.value:null}async function _e(){const e=await X();return{new:await Z(e.new),due:await ee(e.due),learning:await A(L())}}async function Pe(e,n,t){const r=(await m).transaction(["progress","reviews"],"readwrite"),a=r.objectStore("progress"),o=r.objectStore("reviews");await a.put({cardId:e,cardType:n,fsrs:t.card}),await o.add({cardId:e,cardType:n,log:t.log})}function ze(e){const n=we(()=>{const t=ge(e);if(t){const{cardId:r,cardType:a}=t;return async()=>(await m).get("progress",[r,a])}return Te});return B(n)}function Je(){const{result:e,error:n}=B(_e);return pe(()=>{n.value&&console.error(n.value)}),e}export{ze as a,We as i,Pe as r,Je as u};
