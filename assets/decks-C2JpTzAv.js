import{d as p,l as y,u as l}from"./db-CBPHPZsk.js";import{u as w,O as j,b as x,w as k}from"./index-CKpX5h9N.js";import{u as v}from"./fsrs-C70PUnKv.js";import{c as g,x as m}from"./index-ChzRPr1n.js";function D(e){return e!=null}async function b(e,s,r,i,t){const o=await e.get(r);if(o){if(o.decks.includes(t.name))return;o.decks.push(t.name),o.deckPositions.push({deck:t.name,priority:t.priority,order:i}),t.priority===o.position.priority?o.position.order=Math.min(i,o.position.order):t.priority<o.position.priority&&(o.position.priority=t.priority,o.position.order=i),await e.put(o)}else await e.add({id:r,value:String.fromCodePoint(r),types:["kanji-read","kanji-write"],decks:[t.name],position:{priority:t.priority,order:i},deckPositions:[{deck:t.name,priority:t.priority,order:i}]}),await s.add({cardId:r,cardType:"kanji-write",fsrs:k()}),await s.add({cardId:r,cardType:"kanji-read",fsrs:k()})}async function R(e){const s=(await p).transaction(["cards","decks","progress"],"readwrite");await s.objectStore("decks").add(e);const i=s.objectStore("cards"),t=s.objectStore("progress");let o=0;for(const a of e.cards)o+=1,await b(i,t,a,o,e);await s.done,y.postMessage("deck-added")}async function V(e,s){const r=await(await p).getAllKeysFromIndex("decks","category",e),i=await Promise.all(s.filter(({name:n})=>!r.includes(n)).map(async({name:n,label:f,priority:c,content:d})=>{const S=(await(await fetch(d)).text()).split(`
`).map(I=>I.codePointAt(0)).filter(D);return{name:n,label:f,priority:c,category:e,cards:S}})),t=(await p).transaction(["cards","decks","progress"],"readwrite"),o=t.objectStore("decks"),a=t.objectStore("cards"),u=t.objectStore("progress");for(const n of i){await o.add(n);let f=0;for(const c of n.cards)f+=1,await b(a,u,c,f,n)}await t.done,y.postMessage("deck-category-added")}function P(e,s){const r=e.decks.indexOf(s);r!==-1&&e.decks.splice(r,1);const i=e.deckPositions.findIndex(t=>t.deck===s);if(i!==-1){const[t]=e.deckPositions.splice(i,1);if(t.priority===e.position.priority&&t.order===e.position.order){let o=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const u of e.deckPositions)u.priority<o&&(o=u.priority,a=u.order);e.position.priority=o,e.position.order=a}}}async function N(e){const s=(await p).transaction(["cards","decks"],"readwrite"),r=s.objectStore("decks"),i=s.objectStore("cards");await r.delete(e);const t=i.index("decks").iterate(IDBKeyRange.only(e));for await(const o of t){const a=o.value;P(o.value,e),o.update(a)}await s.done,y.postMessage("deck-removed")}async function M(e){const s=(await p).transaction(["cards","decks"],"readwrite"),r=await s.objectStore("decks").index("category").getAllKeys(e);for(const i of r)await N(i);await s.done}async function T(e,s=new j(x())){const r=(await p).transaction(["cards","progress"]),i=r.objectStore("cards"),t=r.objectStore("progress"),o={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},a=new Date,u=i.index("decks").iterate(IDBKeyRange.only(e));for await(const n of u)for(const[f,c]of Object.entries(o)){const d=await t.get([n.primaryKey,f]);d&&(d.fsrs.state===w.New?c.new+=1:d.fsrs.state===w.Learning||d.fsrs.state===w.Relearning||d.fsrs.due<a?c.due+=1:s.get_retrievability(d.fsrs,a,!1)>.99?c.know+=1:c.review+=1)}return o}function B(e){const s=g(()=>{const i=m(e);return async()=>(await p).get("decks",i)}),{result:r}=l(s);return r}function _(){return l(async()=>(await p).transaction("decks").store.index("category+priority").getAll()).result}function q(e){const s=v(),r=g(()=>{const t=m(e);return()=>T(t,s.value)}),{result:i}=l(r);return i}export{_ as a,B as b,R as c,N as d,V as e,M as f,q as u};
