import{u as o}from"./index-Bk94BvIa.js";import{u as I,E as l,m as f}from"./index-v4MgLGDb.js";import{d as s,l as k,u as x}from"./db-ywXYyXbd.js";import{g as M,s as O,v as P}from"./index-uL2dLKam.js";async function m(e){let n=0;for await(const t of await e)n+=1;return n}async function d(e){for await(const n of await e)return n}async function*D(e,n){let t=0;for await(const r of n){if(t>=e)return;yield r,t+=1}}const R=I("shodoku.app.preferences.limit.due",50),N=I("shodoku.app.preferences.limit.new",10);async function A(e={new:N.value,due:R.value}){return await(await s).add("review-limits",{time:new Date,count:e}),k.postMessage("review-limit-increased")}async function*g(e){const n=new Set;let t=await(await s).transaction("progress").store.index("state+due").openCursor();for(;t;){const[r,a]=t.key;if(r<o.Learning){t=await t.continue([o.Learning,l]);continue}if(r>o.Learning&&r<o.Relearning){t=await t.continue([o.Relearning,l]);continue}if(!e||a<e){const[i]=t.primaryKey;n.has(i)||(yield t,n.add(i))}t=await t.continue()}}async function S(){const e=new Set,n=(await s).transaction("reviews").store.index("review").iterate(IDBKeyRange.lowerBound(f()));for await(const t of n)e.add(t.value.cardId);return e}async function L(){const e=new Date;return(await s).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([o.New,f()],[o.New,e],!0,!0))}async function*b(){const e=await S(),n=(await s).transaction(["cards","progress"],"readwrite"),t=n.objectStore("cards"),r=n.objectStore("progress").index("cardId+cardType+state");let a=await t.index("position").openKeyCursor(IDBKeyRange.bound([0,0],[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],!1,!0));for(;a;){if(e.has(a.primaryKey)){a=await a.continue();continue}let i=await r.openCursor([a.primaryKey,"kanji-write",o.New]);i||(i=await r.openCursor([a.primaryKey,"kanji-read",o.New])),i&&(yield i),a=await a.continue()}}async function h(){const e=new Date;return(await s).transaction("reviews").store.index("state+review").count(IDBKeyRange.bound([o.Review,f()],[o.Review,e],!1,!0))}async function*K(){const e=new Date,n=await S(),t=(await s).transaction(["cards","progress","reviews"],"readonly"),r=t.objectStore("cards"),a=t.objectStore("progress"),i=IDBKeyRange.bound([o.Review,l],[o.Review,e],!1,!0);let c=await a.index("state+due").openCursor(i);for(;c;){const[u]=c.primaryKey;if(!n.has(u)){const w=await r.get(u);w&&w.position.priority<Number.POSITIVE_INFINITY&&(yield c)}c=await c.continue()}}async function j(){const e=await(await s).getAllFromIndex("review-limits","time",IDBKeyRange.lowerBound(f())),n={due:0,new:0};for(const{count:t}of e)n.due+=t.due,n.new+=t.new;return n}async function B(e=0){const n=await L(),t=Math.max(0,N.value+e-n);return m(D(t,b()))}async function T(e=0){const n=await h(),t=Math.max(0,R.value+e-n);return m(D(t,K()))}async function F(){const e=await d(g(new Date));if(e)return e.value;const n=await j(),t=await B(n.new),r=await L(),a=await T(n.due),i=await h(),c=t+r,u=a+i,w=t+a,y=Math.ceil((c+u)/c),E=Math.floor(y/2);if(t>0&&(a===0||w%y===E)){const C=await d(b());if(C)return C.value}const v=await d(K());if(v)return v.value;const p=await d(g());return p?p.value:null}async function V(){const e=await j();return{new:await B(e.new),due:await T(e.due),learning:await m(g())}}async function z(e,n,t){const r=(await s).transaction(["progress","reviews"],"readwrite"),a=r.objectStore("progress"),i=r.objectStore("reviews");await a.put({cardId:e,cardType:n,fsrs:t.card}),await i.add({cardId:e,cardType:n,log:t.log})}function G(e){const n=M(()=>{const t=P(e);if(t){const{cardId:r,cardType:a}=t;return async()=>(await s).get("progress",[r,a])}return F});return x(n)}function H(){const{result:e,error:n}=x(V);return O(()=>{n.value&&console.error(n.value)}),e}export{G as a,A as i,z as r,H as u};
