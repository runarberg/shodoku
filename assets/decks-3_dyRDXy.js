import{F as j,a as i,S as y,g as v,c as l}from"./index-CZZIk45U.js";import{d,l as w}from"./db-D-l1LJxU.js";function p(e){return Math.floor(Math.random()*16**e).toString(16).padStart(e,"0")}function D(){try{return crypto.randomUUID()}catch{return[p(8),p(4),p(4),p(4),`${p(6)}${p(6)}`].join("-")}}function b(e){return e!=null}async function g(e,t){const a=e.objectStore("cards"),r=e.objectStore("progress"),s=new Date;if(!await a.getKey(t)){const o={id:t,value:String.fromCodePoint(t),types:["kanji-read","kanji-write"],createdAt:s},c={cardId:t,cardType:"kanji-write",fsrs:l()},n={cardId:t,cardType:"kanji-read",fsrs:l()};a.add(o),r.add(c),r.add(n),i([{store:"cards",op:"add",key:t},{store:"progress",op:"add",key:[t,"kanji-write"]},{store:"progress",op:"add",key:[t,"kanji-read"]}])}}async function x(e,t){let a=t,r=!1;a||(r=!0,a=(await d).transaction(["cards","decks","progress"],"readwrite"));const s=a.objectStore("decks"),o=await s.get(e);if(!o)throw new Error("Deck does not exist");if(o.active)return o;const c=new Date;await s.put({...o,active:!0,updatedAt:c});for(const n of o.cards)g(a,n);return i([{store:"decks",key:o.name,op:"put"}]),r&&(await a.done,w.postMessage("deck-added")),o}async function h(e,t){const a=new Date,r=await Promise.all(t.map(async({name:c,label:n,priority:u,content:f})=>{if(await(await d).getKey("decks",c))return c;const m=(await(await fetch(f)).text()).split(`
`).map(S=>S.codePointAt(0)).filter(b);return{name:c,label:n,priority:u,category:e,cards:m,active:!0}})),s=(await d).transaction(["cards","decks","progress"],"readwrite"),o=s.objectStore("decks");for(const c of r)if(typeof c=="string")x(c,s);else{const n={...c,createdAt:a};await o.add(n),i([{store:"decks",op:"add",key:n.name}]);for(const u of n.cards)g(s,u)}await s.done,w.postMessage("deck-category-added")}async function M(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e);if(!r||!r.active)return;const s=new Date;await a.put({...r,active:!1,updatedAt:s}),i([{store:"decks",op:"put",key:r.name}]),await t.done,w.postMessage("deck-removed")}async function T(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=await t.objectStore("decks").index("category").getAllKeys(e);for(const r of a)await M(r);await t.done}async function N(e,t=new j(v())){const a=(await d).transaction(["decks","progress"]),r=a.objectStore("progress"),s={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},o=new Date,c=await a.objectStore("decks").get(e);if(!c)return s;for await(const n of c.cards)for(const[u,f]of Object.entries(s)){const k=await r.get([n,u]);k&&(k.fsrs.state===y.New?f.new+=1:k.fsrs.state===y.Learning||k.fsrs.state===y.Relearning||k.fsrs.due<o?f.due+=1:t.get_retrievability(k.fsrs,o,!1)>.99?f.know+=1:f.review+=1)}return s}async function K({name:e=`custom/${D()}`,active:t=!0,createdAt:a=new Date,...r}){const s={...r,name:e,active:t,createdAt:a},o=(await d).transaction(["decks","cards","progress"],"readwrite");await o.objectStore("decks").add(s),i([{store:"decks",op:"add",key:s.name}]);for(const c of s.cards)g(o,c);return await o.done,w.postMessage("deck-created"),s}async function $(e){const t=(await d).transaction(["decks","cards","progress"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e.name);if(!r){await a.add(e),i([{store:"decks",op:"add",key:e.name}]),w.postMessage("deck-created");return}const s=new Date;await a.put({...e,updatedAt:s}),i([{store:"decks",op:"put",key:e.name}]);for(const o of e.cards)r.cards.includes(o)||g(t,o);await t.done,w.postMessage("custom-deck-edited")}async function B(e){await(await d).transaction(["decks","cards"],"readwrite").objectStore("decks").delete(e),i([{store:"decks",op:"delete",key:e}]),w.postMessage("custom-deck-removed")}export{x as a,h as b,K as c,M as d,$ as e,T as f,N as g,B as r};
