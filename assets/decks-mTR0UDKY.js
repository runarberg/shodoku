import{F as j,g as k,k as b,e as x,W as M,S as l,h as A,j as S}from"./reviews-DovQcjTA.js";import{d,l as w}from"./db-BhNzgzsk.js";function f(e){return Math.floor(Math.random()*16**e).toString(16).padStart(e,"0")}function P(){try{return crypto.randomUUID()}catch{return[f(8),f(4),f(4),f(4),`${f(6)}${f(6)}`].join("-")}}function h(e){return e!=null}async function g(e,t){const a=e.objectStore("cards"),r=e.objectStore("progress"),s=new Date;if(!await a.getKey(t)){const o={id:t,value:String.fromCodePoint(t),types:["kanji-read","kanji-write"],createdAt:s},c={cardId:t,cardType:"kanji-write",fsrs:S()},n={cardId:t,cardType:"kanji-read",fsrs:S()};a.add(o),r.add(c),r.add(n),k([{store:"cards",op:"add",key:t},{store:"progress",op:"add",key:[t,"kanji-write"]},{store:"progress",op:"add",key:[t,"kanji-read"]}])}}async function C(e,t){let a=t,r=!1;a||(r=!0,a=(await d).transaction(["cards","decks","progress"],"readwrite"));const s=a.objectStore("decks"),o=await s.get(e);if(!o)throw new Error("Deck does not exist");if(o.active)return o;const c=new Date;await s.put({...o,active:!0,updatedAt:c});for(const n of o.cards)g(a,n);return k([{store:"decks",key:o.name,op:"put"}]),r&&(await a.done,w.postMessage("deck-added")),o}async function K(e,t){const a=new Date,r=await Promise.all(t.map(async({name:c,label:n,priority:u,content:y})=>{if(await(await d).getKey("decks",c))return c;const v=(await(await fetch(y)).text()).split(`
`).map(D=>D.codePointAt(0)).filter(h);return{name:c,label:n,priority:u,category:e,cards:v,active:!0}})),s=(await d).transaction(["cards","decks","progress"],"readwrite"),o=s.objectStore("decks");for(const c of r)if(typeof c=="string")C(c,s);else{const n={...c,createdAt:a};await o.add(n),k([{store:"decks",op:"add",key:n.name}]);for(const u of n.cards)g(s,u)}await s.done,w.postMessage("deck-category-added")}async function I(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e);if(!r||!r.active)return;const s=new Date;await a.put({...r,active:!1,updatedAt:s}),k([{store:"decks",op:"put",key:r.name}]),await t.done,w.postMessage("deck-removed")}async function N(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=await t.objectStore("decks").index("category").getAllKeys(e);for(const r of a)await I(r);await t.done}async function R(e,t=new j(A())){const a=(await d).transaction(["decks","progress"]),r=a.objectStore("progress"),s={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},o=new Date,c=await a.objectStore("decks").get(e);if(!c)return s;const n=b.value/100,u=new Date(Date.now()+x.value*M);for await(const y of c.cards)for(const[m,p]of Object.entries(s)){const i=await r.get([y,m]);i&&(i.fsrs.state===l.New?p.new+=1:i.fsrs.state===l.Learning||i.fsrs.state===l.Relearning||i.fsrs.due<o?p.due+=1:i.fsrs.due>u&&t.get_retrievability(i.fsrs,o,!1)>n?p.know+=1:p.review+=1)}return s}async function W({name:e=`custom/${P()}`,active:t=!0,createdAt:a=new Date,...r}){const s={...r,name:e,active:t,createdAt:a},o=(await d).transaction(["decks","cards","progress"],"readwrite");await o.objectStore("decks").add(s),k([{store:"decks",op:"add",key:s.name}]);for(const c of s.cards)g(o,c);return await o.done,w.postMessage("deck-created"),s}async function $(e){const t=(await d).transaction(["decks","cards","progress"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e.name);if(!r){await a.add(e),k([{store:"decks",op:"add",key:e.name}]),w.postMessage("deck-created");return}const s=new Date;await a.put({...e,updatedAt:s}),k([{store:"decks",op:"put",key:e.name}]);for(const o of e.cards)r.cards.includes(o)||g(t,o);await t.done,w.postMessage("custom-deck-edited")}async function B(e){await(await d).transaction(["decks","cards"],"readwrite").objectStore("decks").delete(e),k([{store:"decks",op:"delete",key:e}]),w.postMessage("custom-deck-removed")}export{C as a,K as b,W as c,I as d,$ as e,N as f,R as g,B as r};
