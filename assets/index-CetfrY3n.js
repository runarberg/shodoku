typeof registration<"u"&&registration.scope;class h{promise;resolve;reject;constructor(){this.promise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}}const c=(r,t)=>new Promise(e=>{const i=new MessageChannel;i.port1.onmessage=s=>{e(s.data)},r.postMessage(t,[i.port2])});class n{type;target;sw;originalEvent;isExternal;constructor(t,e){this.type=t,Object.assign(this,e)}}class l{_eventListenerRegistry=new Map;addEventListener(t,e){this._getEventListenersByType(t).add(e)}removeEventListener(t,e){this._getEventListenersByType(t).delete(e)}dispatchEvent(t){t.target=this;const e=this._getEventListenersByType(t.type);for(const i of e)i(t)}_getEventListenersByType(t){return this._eventListenerRegistry.has(t)||this._eventListenerRegistry.set(t,new Set),this._eventListenerRegistry.get(t)}}function g(r,t){const{href:e}=location;return new URL(r,e).href===new URL(t,e).href}const _=200,d=6e4,p={type:"SKIP_WAITING"};class w extends l{_scriptURL;_registerOptions={};_updateFoundCount=0;_swDeferred=new h;_activeDeferred=new h;_controllingDeferred=new h;_registrationTime=0;_isUpdate;_compatibleControllingSW;_registration;_sw;_ownSWs=new Set;_externalSW;_waitingTimeout;constructor(t,e={}){super(),this._scriptURL=t,this._registerOptions=e,navigator.serviceWorker.addEventListener("message",this._onMessage)}async register({immediate:t=!1}={}){!t&&document.readyState!=="complete"&&await new Promise(i=>window.addEventListener("load",i)),this._isUpdate=!!navigator.serviceWorker.controller,this._compatibleControllingSW=this._getControllingSWIfCompatible(),this._registration=await this._registerScript(),this._compatibleControllingSW&&(this._sw=this._compatibleControllingSW,this._activeDeferred.resolve(this._compatibleControllingSW),this._controllingDeferred.resolve(this._compatibleControllingSW),this._compatibleControllingSW.addEventListener("statechange",this._onStateChange,{once:!0}));const e=this._registration.waiting;return e&&g(e.scriptURL,this._scriptURL.toString())&&(this._sw=e,Promise.resolve().then(()=>{this.dispatchEvent(new n("waiting",{sw:e,wasWaitingBeforeRegister:!0}))})),this._sw&&(this._swDeferred.resolve(this._sw),this._ownSWs.add(this._sw)),this._registration.addEventListener("updatefound",this._onUpdateFound),navigator.serviceWorker.addEventListener("controllerchange",this._onControllerChange),this._registration}async update(){this._registration&&await this._registration.update()}get active(){return this._activeDeferred.promise}get controlling(){return this._controllingDeferred.promise}getSW(){return this._sw!==void 0?Promise.resolve(this._sw):this._swDeferred.promise}async messageSW(t){const e=await this.getSW();return c(e,t)}messageSkipWaiting(){this._registration?.waiting&&c(this._registration.waiting,p)}_getControllingSWIfCompatible(){const t=navigator.serviceWorker.controller;if(t&&g(t.scriptURL,this._scriptURL.toString()))return t}async _registerScript(){try{const t=await navigator.serviceWorker.register(this._scriptURL,this._registerOptions);return this._registrationTime=performance.now(),t}catch(t){throw t}}_onUpdateFound=t=>{const e=this._registration,i=e.installing,s=this._updateFoundCount>0||!g(i.scriptURL,this._scriptURL.toString())||performance.now()>this._registrationTime+d;s?(this._externalSW=i,e.removeEventListener("updatefound",this._onUpdateFound)):(this._sw=i,this._ownSWs.add(i),this._swDeferred.resolve(i)),this.dispatchEvent(new n("installing",{sw:i,originalEvent:t,isExternal:s,isUpdate:this._isUpdate})),++this._updateFoundCount,i.addEventListener("statechange",this._onStateChange)};_onStateChange=t=>{const e=this._registration,i=t.target,{state:s}=i,o=i===this._externalSW,a={sw:i,isExternal:o,originalEvent:t};!o&&this._isUpdate&&(a.isUpdate=!0),this.dispatchEvent(new n(s,a)),s==="installed"?this._waitingTimeout=self.setTimeout(()=>{s==="installed"&&e.waiting===i&&this.dispatchEvent(new n("waiting",a))},_):s==="activating"&&(clearTimeout(this._waitingTimeout),o||this._activeDeferred.resolve(i))};_onControllerChange=t=>{const e=this._sw,i=e!==navigator.serviceWorker.controller;this.dispatchEvent(new n("controlling",{isExternal:i,originalEvent:t,sw:e,isUpdate:this._isUpdate})),i||this._controllingDeferred.resolve(e)};_onMessage=async t=>{const{data:e,ports:i,source:s}=t;await this.getSW(),this._ownSWs.has(s)&&this.dispatchEvent(new n("message",{data:e,originalEvent:t,ports:i,sw:s}))}}export{w as Serwist,n as SerwistEvent,c as messageSW};
//# sourceMappingURL=index-CetfrY3n.js.map
