import{d as p,l as y}from"./channels-Cq-RpcWF.js";import{u as l}from"./db-2hokmpug.js";import{u as w,O as j,b as x,w as k}from"./index-TyJKmroR.js";import{u as v}from"./fsrs-B6nyivvS.js";import{c as g,x as m}from"./index-Bay301qk.js";function D(t){return t!=null}async function b(t,s,r,i,e){const o=await t.get(r);if(o){if(o.decks.includes(e.name))return;o.decks.push(e.name),o.deckPositions.push({deck:e.name,priority:e.priority,order:i}),e.priority===o.position.priority?o.position.order=Math.min(i,o.position.order):e.priority<o.position.priority&&(o.position.priority=e.priority,o.position.order=i),await t.put(o)}else await t.add({id:r,value:String.fromCodePoint(r),types:["kanji-read","kanji-write"],decks:[e.name],position:{priority:e.priority,order:i},deckPositions:[{deck:e.name,priority:e.priority,order:i}]}),await s.add({cardId:r,cardType:"kanji-write",fsrs:k()}),await s.add({cardId:r,cardType:"kanji-read",fsrs:k()})}async function V(t){const s=(await p).transaction(["cards","decks","progress"],"readwrite");await s.objectStore("decks").add(t);const i=s.objectStore("cards"),e=s.objectStore("progress");let o=0;for(const a of t.cards)o+=1,await b(i,e,a,o,t);await s.done,y.postMessage("deck-added")}async function M(t,s){const r=await(await p).getAllKeysFromIndex("decks","category",t),i=await Promise.all(s.filter(({name:n})=>!r.includes(n)).map(async({name:n,label:f,priority:c,content:d})=>{const S=(await(await fetch(d)).text()).split(`
`).map(I=>I.codePointAt(0)).filter(D);return{name:n,label:f,priority:c,category:t,cards:S}})),e=(await p).transaction(["cards","decks","progress"],"readwrite"),o=e.objectStore("decks"),a=e.objectStore("cards"),u=e.objectStore("progress");for(const n of i){await o.add(n);let f=0;for(const c of n.cards)f+=1,await b(a,u,c,f,n)}await e.done,y.postMessage("deck-category-added")}function P(t,s){const r=t.decks.indexOf(s);r!==-1&&t.decks.splice(r,1);const i=t.deckPositions.findIndex(e=>e.deck===s);if(i!==-1){const[e]=t.deckPositions.splice(i,1);if(e.priority===t.position.priority&&e.order===t.position.order){let o=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const u of t.deckPositions)u.priority<o&&(o=u.priority,a=u.order);t.position.priority=o,t.position.order=a}}}async function N(t){const s=(await p).transaction(["cards","decks"],"readwrite"),r=s.objectStore("decks"),i=s.objectStore("cards");await r.delete(t);const e=i.index("decks").iterate(IDBKeyRange.only(t));for await(const o of e){const a=o.value;P(o.value,t),o.update(a)}await s.done,y.postMessage("deck-removed")}async function B(t){const s=(await p).transaction(["cards","decks"],"readwrite"),r=await s.objectStore("decks").index("category").getAllKeys(t);for(const i of r)await N(i);await s.done}async function T(t,s=new j(x())){const r=(await p).transaction(["cards","progress"]),i=r.objectStore("cards"),e=r.objectStore("progress"),o={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},a=new Date,u=i.index("decks").iterate(IDBKeyRange.only(t));for await(const n of u)for(const[f,c]of Object.entries(o)){const d=await e.get([n.primaryKey,f]);d&&(d.fsrs.state===w.New?c.new+=1:d.fsrs.state===w.Learning||d.fsrs.state===w.Relearning||d.fsrs.due<a?c.due+=1:s.get_retrievability(d.fsrs,a,!1)>.99?c.know+=1:c.review+=1)}return o}function _(t){const s=g(()=>{const i=m(t);return async()=>(await p).get("decks",i)}),{result:r}=l(s);return r}function q(){return l(async()=>(await p).transaction("decks").store.index("category+priority").getAll()).result}function E(t){const s=v(),r=g(()=>{const e=m(t);return()=>T(e,s.value)}),{result:i}=l(r);return i}export{q as a,_ as b,V as c,N as d,M as e,B as f,E as u};
