{"version":3,"file":"index-CetfrY3n.js","sources":["../../node_modules/serwist/dist/chunks/waitUntil.js","../../node_modules/@serwist/window/dist/index.js"],"sourcesContent":["const messages = {\n    \"invalid-value\": ({ paramName, validValueDescription, value })=>{\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n    },\n    \"not-an-array\": ({ moduleName, className, funcName, paramName })=>{\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n    },\n    \"incorrect-type\": ({ expectedType, paramName, moduleName, className, funcName })=>{\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n    },\n    \"incorrect-class\": ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem })=>{\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        if (isReturnValueProblem) {\n            return `The return value from '${moduleName}.${classNameStr}${funcName}()' must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    },\n    \"missing-a-method\": ({ expectedMethod, paramName, moduleName, className, funcName })=>{\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n    },\n    \"add-to-cache-list-unexpected-type\": ({ entry })=>{\n        return `An unexpected entry was passed to 'serwist.Serwist.addToPrecacheList()' The entry '${JSON.stringify(entry)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`;\n    },\n    \"add-to-cache-list-conflicting-entries\": ({ firstEntry, secondEntry })=>{\n        if (!firstEntry || !secondEntry) {\n            throw new Error(\"Unexpected input to \" + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${firstEntry} but different revision details. Serwist is unable to cache and version the asset correctly. Please remove one of the entries.`;\n    },\n    \"plugin-error-request-will-fetch\": ({ thrownErrorMessage })=>{\n        if (!thrownErrorMessage) {\n            throw new Error(\"Unexpected input to \" + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugin's 'requestWillFetch()' method. The thrown error message was: '${thrownErrorMessage}'.`;\n    },\n    \"invalid-cache-name\": ({ cacheNameId, value })=>{\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for setCacheDetails({${cacheNameId}: '...'}). Received a value of '${JSON.stringify(value)}'`;\n    },\n    \"unregister-route-but-not-found-with-method\": ({ method })=>{\n        if (!method) {\n            throw new Error(\"Unexpected input to \" + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously registered for the method type '${method}'.`;\n    },\n    \"unregister-route-route-not-registered\": ()=>{\n        return `The route you're trying to unregister was not previously ` + \"registered.\";\n    },\n    \"queue-replay-failed\": ({ name })=>{\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    \"duplicate-queue-name\": ({ name })=>{\n        return `The queue name '${name}' is already being used. All instances of 'serwist.BackgroundSyncQueue' must be given unique names.`;\n    },\n    \"expired-test-without-max-age\": ({ methodName, paramName })=>{\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n    },\n    \"unsupported-route-type\": ({ moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter was an unsupported type. Please check the docs for ${moduleName}.${className}.${funcName} for valid input types.`;\n    },\n    \"not-array-of-class\": ({ value, expectedClass, moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter must be an array of '${expectedClass}' objects. Received '${JSON.stringify(value)},'. Please check the call to ${moduleName}.${className}.${funcName}() to fix the issue.`;\n    },\n    \"max-entries-or-age-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.maxEntries' or 'config.maxAgeSeconds' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"statuses-or-headers-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.statuses' or 'config.headers' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"invalid-string\": ({ moduleName, funcName, paramName })=>{\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${moduleName}.${funcName}() for more info.`;\n    },\n    \"channel-name-required\": ()=>{\n        return \"You must provide a channelName to construct a \" + \"BroadcastCacheUpdate instance.\";\n    },\n    \"invalid-responses-are-same-args\": ()=>{\n        return \"The arguments passed into responsesAreSame() appear to be \" + \"invalid. Please ensure valid Responses are used.\";\n    },\n    \"expire-custom-caches-only\": ()=>{\n        return `You must provide a 'cacheName' property when using the ` + \"expiration plugin with a runtime caching strategy.\";\n    },\n    \"unit-must-be-bytes\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"single-range-only\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"invalid-range-values\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"no-range-header\": ()=>{\n        return \"No Range header was found in the Request provided.\";\n    },\n    \"range-not-satisfiable\": ({ size, start, end })=>{\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n    },\n    \"attempt-to-cache-non-get-request\": ({ url, method })=>{\n        return `Unable to cache '${url}' because it is a '${method}' request and only 'GET' requests can be cached.`;\n    },\n    \"cache-put-with-no-response\": ({ url })=>{\n        return `There was an attempt to cache '${url}' but the response was not defined.`;\n    },\n    \"no-response\": ({ url, error })=>{\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    \"bad-precaching-response\": ({ url, status })=>{\n        return `The precaching request for '${url}' failed${status ? ` with an HTTP status of ${status}.` : \".\"}`;\n    },\n    \"non-precached-url\": ({ url })=>{\n        return `'createHandlerBoundToURL(\"${url}\")' was called, but that URL is not precached. Please pass in a URL that is precached instead.`;\n    },\n    \"add-to-cache-list-conflicting-integrities\": ({ url })=>{\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${url} with different integrity values. Please remove one of them.`;\n    },\n    \"missing-precache-entry\": ({ cacheName, url })=>{\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    \"cross-origin-copy-response\": ({ origin })=>{\n        return `'@serwist/core.copyResponse()' can only be used with same-origin responses. It was passed a response with origin ${origin}.`;\n    },\n    \"opaque-streams-source\": ({ type })=>{\n        const message = `One of the '@serwist/streams' sources resulted in an '${type}' response.`;\n        if (type === \"opaqueredirect\") {\n            return `${message} Please do not use a navigation request that results in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    }\n};\n\nconst fallback = (code, ...args)=>{\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {})=>{\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nconst messageGenerator = process.env.NODE_ENV === \"production\" ? fallback : generatorFunction;\n\nclass SerwistError extends Error {\n    details;\n    constructor(errorCode, details){\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\n\nconst isArray = (value, details)=>{\n    if (!Array.isArray(value)) {\n        throw new SerwistError(\"not-an-array\", details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details)=>{\n    const type = typeof object[expectedMethod];\n    if (type !== \"function\") {\n        details.expectedMethod = expectedMethod;\n        throw new SerwistError(\"missing-a-method\", details);\n    }\n};\nconst isType = (object, expectedType, details)=>{\n    if (typeof object !== expectedType) {\n        details.expectedType = expectedType;\n        throw new SerwistError(\"incorrect-type\", details);\n    }\n};\nconst isInstance = (object, expectedClass, details)=>{\n    if (!(object instanceof expectedClass)) {\n        details.expectedClassName = expectedClass.name;\n        throw new SerwistError(\"incorrect-class\", details);\n    }\n};\nconst isOneOf = (value, validValues, details)=>{\n    if (!validValues.includes(value)) {\n        details.validValueDescription = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new SerwistError(\"invalid-value\", details);\n    }\n};\nconst isArrayOfClass = (value, expectedClass, details)=>{\n    const error = new SerwistError(\"not-array-of-class\", details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value){\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports = process.env.NODE_ENV === \"production\" ? null : {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isType,\n    isArrayOfClass\n};\n\nconst logger = process.env.NODE_ENV === \"production\" || typeof self === \"undefined\" ? null : (()=>{\n    if (!(\"__WB_DISABLE_DEV_LOGS\" in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n    }\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: \"#7f8c8d\",\n        log: \"#2ecc71\",\n        warn: \"#f39c12\",\n        error: \"#c0392b\",\n        groupCollapsed: \"#3498db\",\n        groupEnd: null\n    };\n    const print = (method, args)=>{\n        if (self.__WB_DISABLE_DEV_LOGS) {\n            return;\n        }\n        if (method === \"groupCollapsed\") {\n            if (typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            \"border-radius: 0.5em\",\n            \"color: white\",\n            \"font-weight: bold\",\n            \"padding: 2px 0.5em\"\n        ];\n        const logPrefix = inGroup ? [] : [\n            \"%cserwist\",\n            styles.join(\";\")\n        ];\n        console[method](...logPrefix, ...args);\n        if (method === \"groupCollapsed\") {\n            inGroup = true;\n        }\n        if (method === \"groupEnd\") {\n            inGroup = false;\n        }\n    };\n    const loggerMethods = Object.keys(methodToColorMap);\n    return loggerMethods.reduce((api, method)=>{\n        api[method] = (...args)=>{\n            print(method, args);\n        };\n        return api;\n    }, {});\n})();\n\nconst getFriendlyURL = (url)=>{\n    const urlObj = new URL(String(url), location.href);\n    return urlObj.href.replace(new RegExp(`^${location.origin}`), \"\");\n};\n\nconst _cacheNameDetails = {\n    googleAnalytics: \"googleAnalytics\",\n    precache: \"precache-v2\",\n    prefix: \"serwist\",\n    runtime: \"runtime\",\n    suffix: typeof registration !== \"undefined\" ? registration.scope : \"\"\n};\nconst _createCacheName = (cacheName)=>{\n    return [\n        _cacheNameDetails.prefix,\n        cacheName,\n        _cacheNameDetails.suffix\n    ].filter((value)=>value && value.length > 0).join(\"-\");\n};\nconst eachCacheNameDetail = (fn)=>{\n    for (const key of Object.keys(_cacheNameDetails)){\n        fn(key);\n    }\n};\nconst cacheNames = {\n    updateDetails: (details)=>{\n        eachCacheNameDetail((key)=>{\n            const detail = details[key];\n            if (typeof detail === \"string\") {\n                _cacheNameDetails[key] = detail;\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: ()=>{\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: ()=>{\n        return _cacheNameDetails.suffix;\n    }\n};\n\nclass Deferred {\n    promise;\n    resolve;\n    reject;\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nfunction stripParams(fullURL, ignoreParams) {\n    const strippedURL = new URL(fullURL);\n    for (const param of ignoreParams){\n        strippedURL.searchParams.delete(param);\n    }\n    return strippedURL.href;\n}\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n    const strippedRequestURL = stripParams(request.url, ignoreParams);\n    if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n    }\n    const keysOptions = {\n        ...matchOptions,\n        ignoreSearch: true\n    };\n    const cacheKeys = await cache.keys(request, keysOptions);\n    for (const cacheKey of cacheKeys){\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n            return cache.match(cacheKey, matchOptions);\n        }\n    }\n    return;\n}\n\nconst quotaErrorCallbacks = new Set();\n\nconst executeQuotaErrorCallbacks = async ()=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        logger.log(`About to run ${quotaErrorCallbacks.size} callbacks to clean up caches.`);\n    }\n    for (const callback of quotaErrorCallbacks){\n        await callback();\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(callback, \"is complete.\");\n        }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n        logger.log(\"Finished running callbacks.\");\n    }\n};\n\nfunction timeout(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n\nlet supportStatus;\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response(\"\");\n        if (\"body\" in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            } catch  {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\n\nconst SUBSTRING_TO_FIND = \"-precache-\";\nconst deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND)=>{\n    const cacheNames = await self.caches.keys();\n    const cacheNamesToDelete = cacheNames.filter((cacheName)=>{\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n    });\n    await Promise.all(cacheNamesToDelete.map((cacheName)=>self.caches.delete(cacheName)));\n    return cacheNamesToDelete;\n};\n\nconst cleanupOutdatedCaches = (cacheName)=>{\n    self.addEventListener(\"activate\", (event)=>{\n        event.waitUntil(deleteOutdatedCaches(cacheNames.getPrecacheName(cacheName)).then((cachesDeleted)=>{\n            if (process.env.NODE_ENV !== \"production\") {\n                if (cachesDeleted.length > 0) {\n                    logger.log(\"The following out-of-date precaches were cleaned up automatically:\", cachesDeleted);\n                }\n            }\n        }));\n    });\n};\n\nconst clientsClaim = ()=>{\n    self.addEventListener(\"activate\", ()=>self.clients.claim());\n};\n\nconst waitUntil = (event, asyncFn)=>{\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n};\n\nexport { Deferred as D, SerwistError as S, clientsClaim as a, cleanupOutdatedCaches as b, cacheNames as c, cacheMatchIgnoreParams as d, executeQuotaErrorCallbacks as e, finalAssertExports as f, getFriendlyURL as g, canConstructResponseFromBodyStream as h, logger as l, quotaErrorCallbacks as q, timeout as t, waitUntil as w };\n","import { Deferred, logger } from 'serwist/internal';\nimport { isCurrentPageOutOfScope } from './index.internal.js';\n\nconst messageSW = (sw, data)=>{\n    return new Promise((resolve)=>{\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event)=>{\n            resolve(event.data);\n        };\n        sw.postMessage(data, [\n            messageChannel.port2\n        ]);\n    });\n};\n\nclass SerwistEvent {\n    type;\n    target;\n    sw;\n    originalEvent;\n    isExternal;\n    constructor(type, props){\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n\nclass SerwistEventTarget {\n    _eventListenerRegistry = new Map();\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners){\n            listener(event);\n        }\n    }\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n\nfunction urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n\nconst WAITING_TIMEOUT_DURATION = 200;\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\nconst SKIP_WAITING_MESSAGE = {\n    type: \"SKIP_WAITING\"\n};\nclass Serwist extends SerwistEventTarget {\n    _scriptURL;\n    _registerOptions = {};\n    _updateFoundCount = 0;\n    _swDeferred = new Deferred();\n    _activeDeferred = new Deferred();\n    _controllingDeferred = new Deferred();\n    _registrationTime = 0;\n    _isUpdate;\n    _compatibleControllingSW;\n    _registration;\n    _sw;\n    _ownSWs = new Set();\n    _externalSW;\n    _waitingTimeout;\n    constructor(scriptURL, registerOptions = {}){\n        super();\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        navigator.serviceWorker.addEventListener(\"message\", this._onMessage);\n    }\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== \"production\") {\n            if (this._registrationTime) {\n                logger.error(\"Cannot re-register a Serwist instance after it has been registered. Create a new instance instead.\");\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== \"complete\") {\n            await new Promise((res)=>window.addEventListener(\"load\", res));\n        }\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener(\"statechange\", this._onStateChange, {\n                once: true\n            });\n        }\n        const waitingSW = this._registration.waiting;\n        if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL.toString())) {\n            this._sw = waitingSW;\n            void Promise.resolve().then(()=>{\n                this.dispatchEvent(new SerwistEvent(\"waiting\", {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true\n                }));\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.warn(\"A service worker was already waiting to activate before this script was registered...\");\n                }\n            });\n        }\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(\"Successfully registered service worker.\", this._scriptURL.toString());\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug(\"A service worker with the same script URL is already controlling this page.\");\n                } else {\n                    logger.debug(\"A service worker with a different script URL is currently controlling the page. The browser is now fetching the new script now...\");\n                }\n            }\n            if (isCurrentPageOutOfScope(this._registerOptions.scope || this._scriptURL.toString())) {\n                logger.warn(\"The current page is not in scope for the registered service worker. Was this a mistake?\");\n            }\n        }\n        this._registration.addEventListener(\"updatefound\", this._onUpdateFound);\n        navigator.serviceWorker.addEventListener(\"controllerchange\", this._onControllerChange);\n        return this._registration;\n    }\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.error(\"Cannot update a Serwist instance without being registered. Register the Serwist instance first.\");\n            }\n            return;\n        }\n        await this._registration.update();\n    }\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    getSW() {\n        return this._sw !== undefined ? Promise.resolve(this._sw) : this._swDeferred.promise;\n    }\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    messageSkipWaiting() {\n        if (this._registration?.waiting) {\n            void messageSW(this._registration.waiting, SKIP_WAITING_MESSAGE);\n        }\n    }\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller && urlsMatch(controller.scriptURL, this._scriptURL.toString())) {\n            return controller;\n        }\n        return undefined;\n    }\n    async _registerScript() {\n        try {\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            this._registrationTime = performance.now();\n            return reg;\n        } catch (error) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.error(error);\n            }\n            throw error;\n        }\n    }\n    _onUpdateFound = (originalEvent)=>{\n        const registration = this._registration;\n        const installingSW = registration.installing;\n        const updateLikelyTriggeredExternally = this._updateFoundCount > 0 || !urlsMatch(installingSW.scriptURL, this._scriptURL.toString()) || performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION;\n        if (updateLikelyTriggeredExternally) {\n            this._externalSW = installingSW;\n            registration.removeEventListener(\"updatefound\", this._onUpdateFound);\n        } else {\n            this._sw = installingSW;\n            this._ownSWs.add(installingSW);\n            this._swDeferred.resolve(installingSW);\n            if (process.env.NODE_ENV !== \"production\") {\n                if (this._isUpdate) {\n                    logger.log(\"Updated service worker found. Installing now...\");\n                } else {\n                    logger.log(\"Service worker is installing...\");\n                }\n            }\n        }\n        this.dispatchEvent(new SerwistEvent(\"installing\", {\n            sw: installingSW,\n            originalEvent,\n            isExternal: updateLikelyTriggeredExternally,\n            isUpdate: this._isUpdate\n        }));\n        ++this._updateFoundCount;\n        installingSW.addEventListener(\"statechange\", this._onStateChange);\n    };\n    _onStateChange = (originalEvent)=>{\n        const registration = this._registration;\n        const sw = originalEvent.target;\n        const { state } = sw;\n        const isExternal = sw === this._externalSW;\n        const eventProps = {\n            sw,\n            isExternal,\n            originalEvent\n        };\n        if (!isExternal && this._isUpdate) {\n            eventProps.isUpdate = true;\n        }\n        this.dispatchEvent(new SerwistEvent(state, eventProps));\n        if (state === \"installed\") {\n            this._waitingTimeout = self.setTimeout(()=>{\n                if (state === \"installed\" && registration.waiting === sw) {\n                    this.dispatchEvent(new SerwistEvent(\"waiting\", eventProps));\n                    if (process.env.NODE_ENV !== \"production\") {\n                        if (isExternal) {\n                            logger.warn(\"An external service worker has installed but is \" + \"waiting for this client to close before activating...\");\n                        } else {\n                            logger.warn(\"The service worker has installed but is waiting \" + \"for existing clients to close before activating...\");\n                        }\n                    }\n                }\n            }, WAITING_TIMEOUT_DURATION);\n        } else if (state === \"activating\") {\n            clearTimeout(this._waitingTimeout);\n            if (!isExternal) {\n                this._activeDeferred.resolve(sw);\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            switch(state){\n                case \"installed\":\n                    if (isExternal) {\n                        logger.warn(\"An external service worker has installed. \" + \"You may want to suggest users reload this page.\");\n                    } else {\n                        logger.log(\"Registered service worker installed.\");\n                    }\n                    break;\n                case \"activated\":\n                    if (isExternal) {\n                        logger.warn(\"An external service worker has activated.\");\n                    } else {\n                        logger.log(\"Registered service worker activated.\");\n                        if (sw !== navigator.serviceWorker.controller) {\n                            logger.warn(\"The registered service worker is active but \" + \"not yet controlling the page. Reload or run \" + \"`clients.claim()` in the service worker.\");\n                        }\n                    }\n                    break;\n                case \"redundant\":\n                    if (sw === this._compatibleControllingSW) {\n                        logger.log(\"Previously controlling service worker now redundant!\");\n                    } else if (!isExternal) {\n                        logger.log(\"Registered service worker now redundant!\");\n                    }\n                    break;\n            }\n        }\n    };\n    _onControllerChange = (originalEvent)=>{\n        const sw = this._sw;\n        const isExternal = sw !== navigator.serviceWorker.controller;\n        this.dispatchEvent(new SerwistEvent(\"controlling\", {\n            isExternal,\n            originalEvent,\n            sw,\n            isUpdate: this._isUpdate\n        }));\n        if (!isExternal) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.log(\"Registered service worker now controlling this page.\");\n            }\n            this._controllingDeferred.resolve(sw);\n        }\n    };\n    _onMessage = async (originalEvent)=>{\n        const { data, ports, source } = originalEvent;\n        await this.getSW();\n        if (this._ownSWs.has(source)) {\n            this.dispatchEvent(new SerwistEvent(\"message\", {\n                data,\n                originalEvent,\n                ports,\n                sw: source\n            }));\n        }\n    };\n}\n\nexport { Serwist, SerwistEvent, messageSW };\n"],"names":["Deferred","resolve","reject","messageSW","sw","data","messageChannel","event","SerwistEvent","type","props","SerwistEventTarget","listener","listeners","urlsMatch","url1","url2","href","WAITING_TIMEOUT_DURATION","REGISTRATION_TIMEOUT_DURATION","SKIP_WAITING_MESSAGE","Serwist","scriptURL","registerOptions","immediate","res","waitingSW","controller","reg","error","originalEvent","registration","installingSW","updateLikelyTriggeredExternally","state","isExternal","eventProps","ports","source"],"mappings":"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","x_google_ignoreList":[0,1]}