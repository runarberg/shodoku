import{F as j,a as i,S as y,g as v,b as l}from"./index-CbYumIFw.js";import{d,l as w}from"./db-DOZG9NOu.js";function p(t){return Math.floor(Math.random()*16**t).toString(16).padStart(t,"0")}function D(){try{return crypto.randomUUID()}catch{return[p(8),p(4),p(4),p(4),`${p(6)}${p(6)}`].join("-")}}function b(t){return t!=null}async function g(t,e){const s=t.objectStore("cards"),r=t.objectStore("progress"),a=new Date;if(!await s.getKey(e)){const c={id:e,value:String.fromCodePoint(e),types:["kanji-read","kanji-write"],createdAt:a},o={cardId:e,cardType:"kanji-write",fsrs:l()},n={cardId:e,cardType:"kanji-read",fsrs:l()};s.add(c),r.add(o),r.add(n),i([{store:"cards",op:"add",key:e},{store:"progress",op:"add",key:[e,"kanji-write"]},{store:"progress",op:"add",key:[e,"kanji-read"]}])}}async function M(t,e){let s=!1;e||(s=!0,e=(await d).transaction(["cards","decks","progress"],"readwrite"));const r=e.objectStore("decks"),a=await r.get(t);if(!a)throw new Error("Deck does not exist");if(a.active)return a;const c=new Date;await r.put({...a,active:!0,updatedAt:c});for(const o of a.cards)g(e,o);return i([{store:"decks",key:a.name,op:"put"}]),s&&(await e.done,w.postMessage("deck-added")),a}async function h(t,e){const s=new Date,r=await Promise.all(e.map(async({name:o,label:n,priority:u,content:f})=>{if(await(await d).getKey("decks",o))return o;const m=(await(await fetch(f)).text()).split(`
`).map(S=>S.codePointAt(0)).filter(b);return{name:o,label:n,priority:u,category:t,cards:m,active:!0}})),a=(await d).transaction(["cards","decks","progress"],"readwrite"),c=a.objectStore("decks");for(const o of r)if(typeof o=="string")M(o,a);else{const n={...o,createdAt:s};await c.add(n),i([{store:"decks",op:"add",key:n.name}]);for(const u of n.cards)g(a,u)}await a.done,w.postMessage("deck-category-added")}async function x(t){const e=(await d).transaction(["cards","decks"],"readwrite"),s=e.objectStore("decks"),r=await s.get(t);if(!r||!r.active)return;const a=new Date;await s.put({...r,active:!1,updatedAt:a}),i([{store:"decks",op:"put",key:r.name}]),await e.done,w.postMessage("deck-removed")}async function T(t){const e=(await d).transaction(["cards","decks"],"readwrite"),s=await e.objectStore("decks").index("category").getAllKeys(t);for(const r of s)await x(r);await e.done}async function N(t,e=new j(v())){const s=(await d).transaction(["decks","progress"]),r=s.objectStore("progress"),a={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},c=new Date,o=await s.objectStore("decks").get(t);if(!o)return a;for await(const n of o.cards)for(const[u,f]of Object.entries(a)){const k=await r.get([n,u]);k&&(k.fsrs.state===y.New?f.new+=1:k.fsrs.state===y.Learning||k.fsrs.state===y.Relearning||k.fsrs.due<c?f.due+=1:e.get_retrievability(k.fsrs,c,!1)>.99?f.know+=1:f.review+=1)}return a}async function K({name:t=`custom/${D()}`,active:e=!0,createdAt:s=new Date,...r}){const a={...r,name:t,active:e,createdAt:s},c=(await d).transaction(["decks","cards","progress"],"readwrite");await c.objectStore("decks").add(a),i([{store:"decks",op:"add",key:a.name}]);for(const o of a.cards)g(c,o);return await c.done,w.postMessage("deck-created"),a}async function $(t){const e=(await d).transaction(["decks","cards","progress"],"readwrite"),s=e.objectStore("decks"),r=await s.get(t.name);if(!r){await s.add(t),i([{store:"decks",op:"add",key:t.name}]),w.postMessage("deck-created");return}const a=new Date;await s.put({...t,updatedAt:a}),i([{store:"decks",op:"put",key:t.name}]);for(const c of t.cards)r.cards.includes(c)||g(e,c);await e.done,w.postMessage("custom-deck-edited")}async function B(t){await(await d).transaction(["decks","cards"],"readwrite").objectStore("decks").delete(t),i([{store:"decks",op:"delete",key:t}]),w.postMessage("custom-deck-removed")}export{M as a,h as b,K as c,x as d,$ as e,T as f,N as g,B as r};
