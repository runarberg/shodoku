import{d as p,l as w,u as y}from"./db-C8CERaXs.js";import{u as f,w as k}from"./index-xwVy6i7n.js";import{c as l,x as g}from"./index-jUm0nxGk.js";function j(t){return t!=null}async function m(t,o,i,r,e){const s=await t.get(i);if(s){if(s.decks.includes(e.name))return;s.decks.push(e.name),s.deckPositions.push({deck:e.name,priority:e.priority,order:r}),e.priority===s.position.priority?s.position.order=Math.min(r,s.position.order):e.priority<s.position.priority&&(s.position.priority=e.priority,s.position.order=r),await t.put(s)}else await t.add({id:i,value:String.fromCodePoint(i),types:["kanji-read","kanji-write"],decks:[e.name],position:{priority:e.priority,order:r},deckPositions:[{deck:e.name,priority:e.priority,order:r}]}),await o.add({cardId:i,cardType:"kanji-write",fsrs:k()}),await o.add({cardId:i,cardType:"kanji-read",fsrs:k()})}async function C(t){const o=(await p).transaction(["cards","decks","progress"],"readwrite");await o.objectStore("decks").add(t);const r=o.objectStore("cards"),e=o.objectStore("progress");let s=0;for(const a of t.cards)s+=1,await m(r,e,a,s,t);await o.done,w.postMessage("deck-added")}async function K(t,o){const i=await(await p).getAllKeysFromIndex("decks","category",t),r=await Promise.all(o.filter(({name:n})=>!i.includes(n)).map(async({name:n,label:d,priority:c,content:S})=>{const b=(await(await fetch(S)).text()).split(`
`).map(I=>I.codePointAt(0)).filter(j);return{name:n,label:d,priority:c,category:t,cards:b}})),e=(await p).transaction(["cards","decks","progress"],"readwrite"),s=e.objectStore("decks"),a=e.objectStore("cards"),u=e.objectStore("progress");for(const n of r){await s.add(n);let d=0;for(const c of n.cards)d+=1,await m(a,u,c,d,n)}await e.done,w.postMessage("deck-category-added")}function x(t,o){const i=t.decks.indexOf(o);i!==-1&&t.decks.splice(i,1);const r=t.deckPositions.findIndex(e=>e.deck===o);if(r!==-1){const[e]=t.deckPositions.splice(r,1);if(e.priority===t.position.priority&&e.order===t.position.order){let s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const u of t.deckPositions)u.priority<s&&(s=u.priority,a=u.order);t.position.priority=s,t.position.order=a}}}async function v(t){const o=(await p).transaction(["cards","decks"],"readwrite"),i=o.objectStore("decks"),r=o.objectStore("cards");await i.delete(t);const e=r.index("decks").iterate(IDBKeyRange.only(t));for await(const s of e){const a=s.value;x(s.value,t),s.update(a)}await o.done,w.postMessage("deck-removed")}async function R(t){const o=(await p).transaction(["cards","decks"],"readwrite"),i=await o.objectStore("decks").index("category").getAllKeys(t);for(const r of i)await v(r);await o.done}async function D(t){const o=(await p).transaction(["cards","progress"]),i=o.objectStore("cards"),r=o.objectStore("progress"),e={"kanji-read":{new:0,due:0,review:0},"kanji-write":{new:0,due:0,review:0}},s=new Date,a=i.index("decks").iterate(IDBKeyRange.only(t));for await(const u of a)for(const[n,d]of Object.entries(e)){const c=await r.get([u.primaryKey,n]);c&&(c.fsrs.state===f.New?d.new+=1:c.fsrs.state===f.Learning||c.fsrs.state===f.Relearning||c.fsrs.due<s?d.due+=1:d.review+=1)}return e}function V(t){const o=l(()=>{const r=g(t);return async()=>(await p).get("decks",r)}),{result:i}=y(o);return i}function F(){return y(async()=>(await p).transaction("decks").store.index("category+priority").getAll()).result}function M(t){const o=l(()=>{const r=g(t);return()=>D(r)}),{result:i}=y(o);return i}export{F as a,V as b,C as c,v as d,K as e,R as f,M as u};
