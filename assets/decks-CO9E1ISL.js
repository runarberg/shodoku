import{F as j,g as k,k as b,e as x,W as M,S as l,h as A,j as S}from"./reviews-BBX2ZUfX.js";import{d,l as w}from"./db-CNlb8ZXY.js";function f(e){return Math.floor(Math.random()*16**e).toString(16).padStart(e,"0")}function P(){try{return crypto.randomUUID()}catch{return[f(8),f(4),f(4),f(4),`${f(6)}${f(6)}`].join("-")}}function h(e){return e!=null}async function g(e,t){const a=e.objectStore("cards"),r=e.objectStore("progress"),o=new Date;if(!await a.getKey(t)){const s={id:t,value:String.fromCodePoint(t),types:["kanji-read","kanji-write"],createdAt:o},c={cardId:t,cardType:"kanji-write",fsrs:S()},n={cardId:t,cardType:"kanji-read",fsrs:S()};a.add(s),r.add(c),r.add(n),k([{store:"cards",op:"add",key:t},{store:"progress",op:"add",key:[t,"kanji-write"]},{store:"progress",op:"add",key:[t,"kanji-read"]}])}}async function C(e,t){let a=t,r=!1;a||(r=!0,a=(await d).transaction(["cards","decks","progress"],"readwrite"));const o=a.objectStore("decks"),s=await o.get(e);if(!s)throw new Error("Deck does not exist");if(s.active)return s;const c=new Date;await o.put({...s,active:!0,updatedAt:c});for(const n of s.cards)g(a,n);return k([{store:"decks",key:s.name,op:"put"}]),r&&(await a.done,w.postMessage("deck-added")),s}async function K(e,t){const a=new Date,r=await Promise.all(t.map(async({name:c,label:n,priority:u,content:y})=>{if(await(await d).getKey("decks",c))return c;const v=(await(await fetch(y)).text()).split(`
`).map(D=>D.codePointAt(0)).filter(h);return{name:c,label:n,priority:u,category:e,cards:v,active:!0}})),o=(await d).transaction(["cards","decks","progress"],"readwrite"),s=o.objectStore("decks");for(const c of r)if(typeof c=="string")C(c,o);else{const n={...c,createdAt:a};await s.add(n),k([{store:"decks",op:"add",key:n.name}]);for(const u of n.cards)g(o,u)}await o.done,w.postMessage("deck-category-added")}async function I(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e);if(!r||!r.active)return;const o=new Date;await a.put({...r,active:!1,updatedAt:o}),k([{store:"decks",op:"put",key:r.name}]),await t.done,w.postMessage("deck-removed")}async function N(e){const t=(await d).transaction(["cards","decks"],"readwrite"),a=await t.objectStore("decks").index("category").getAllKeys(e);for(const r of a)await I(r);await t.done}async function R(e,t=new j(A())){const a=(await d).transaction(["decks","progress"]),r=a.objectStore("progress"),o={"kanji-read":{new:0,due:0,review:0,know:0},"kanji-write":{new:0,due:0,review:0,know:0}},s=new Date,c=await a.objectStore("decks").get(e);if(!c)return o;const n=b.value/100,u=new Date(Date.now()+x.value*M);for await(const y of c.cards)for(const[m,p]of Object.entries(o)){const i=await r.get([y,m]);i&&(i.fsrs.state===l.New?p.new+=1:i.fsrs.state===l.Learning||i.fsrs.state===l.Relearning||i.fsrs.due<s?p.due+=1:i.fsrs.due>u&&t.get_retrievability(i.fsrs,s,!1)>n?p.know+=1:p.review+=1)}return o}async function W({name:e=`custom/${P()}`,active:t=!0,category:a="custom",createdAt:r=new Date,...o}){const s={...o,name:e,active:t,category:a,createdAt:r},c=(await d).transaction(["decks","cards","progress"],"readwrite");await c.objectStore("decks").add(s),k([{store:"decks",op:"add",key:s.name}]);for(const n of s.cards)g(c,n);return await c.done,w.postMessage("deck-created"),s}async function $(e){const t=(await d).transaction(["decks","cards","progress"],"readwrite"),a=t.objectStore("decks"),r=await a.get(e.name);if(!r){await a.add(e),k([{store:"decks",op:"add",key:e.name}]),w.postMessage("deck-created");return}const o=new Date;await a.put({...e,updatedAt:o}),k([{store:"decks",op:"put",key:e.name}]);for(const s of e.cards)r.cards.includes(s)||g(t,s);await t.done,w.postMessage("custom-deck-edited")}async function B(e){await(await d).transaction(["decks","cards"],"readwrite").objectStore("decks").delete(e),k([{store:"decks",op:"delete",key:e}]),w.postMessage("custom-deck-removed")}export{C as a,K as b,W as c,I as d,$ as e,N as f,R as g,B as r};
