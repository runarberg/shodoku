{"version":3,"file":"sw.js","sources":["../node_modules/serwist/dist/chunks/waitUntil.js","../node_modules/idb/build/index.js","../node_modules/serwist/dist/chunks/printInstallDetails.js","../node_modules/serwist/dist/index.js","../src/helpers/time.ts","../src/sw.ts"],"sourcesContent":["const messages = {\n    \"invalid-value\": ({ paramName, validValueDescription, value })=>{\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n    },\n    \"not-an-array\": ({ moduleName, className, funcName, paramName })=>{\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n    },\n    \"incorrect-type\": ({ expectedType, paramName, moduleName, className, funcName })=>{\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n    },\n    \"incorrect-class\": ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem })=>{\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        if (isReturnValueProblem) {\n            return `The return value from '${moduleName}.${classNameStr}${funcName}()' must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    },\n    \"missing-a-method\": ({ expectedMethod, paramName, moduleName, className, funcName })=>{\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n    },\n    \"add-to-cache-list-unexpected-type\": ({ entry })=>{\n        return `An unexpected entry was passed to 'serwist.Serwist.addToPrecacheList()' The entry '${JSON.stringify(entry)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`;\n    },\n    \"add-to-cache-list-conflicting-entries\": ({ firstEntry, secondEntry })=>{\n        if (!firstEntry || !secondEntry) {\n            throw new Error(\"Unexpected input to \" + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${firstEntry} but different revision details. Serwist is unable to cache and version the asset correctly. Please remove one of the entries.`;\n    },\n    \"plugin-error-request-will-fetch\": ({ thrownErrorMessage })=>{\n        if (!thrownErrorMessage) {\n            throw new Error(\"Unexpected input to \" + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugin's 'requestWillFetch()' method. The thrown error message was: '${thrownErrorMessage}'.`;\n    },\n    \"invalid-cache-name\": ({ cacheNameId, value })=>{\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for setCacheDetails({${cacheNameId}: '...'}). Received a value of '${JSON.stringify(value)}'`;\n    },\n    \"unregister-route-but-not-found-with-method\": ({ method })=>{\n        if (!method) {\n            throw new Error(\"Unexpected input to \" + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously registered for the method type '${method}'.`;\n    },\n    \"unregister-route-route-not-registered\": ()=>{\n        return `The route you're trying to unregister was not previously ` + \"registered.\";\n    },\n    \"queue-replay-failed\": ({ name })=>{\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    \"duplicate-queue-name\": ({ name })=>{\n        return `The queue name '${name}' is already being used. All instances of 'serwist.BackgroundSyncQueue' must be given unique names.`;\n    },\n    \"expired-test-without-max-age\": ({ methodName, paramName })=>{\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n    },\n    \"unsupported-route-type\": ({ moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter was an unsupported type. Please check the docs for ${moduleName}.${className}.${funcName} for valid input types.`;\n    },\n    \"not-array-of-class\": ({ value, expectedClass, moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter must be an array of '${expectedClass}' objects. Received '${JSON.stringify(value)},'. Please check the call to ${moduleName}.${className}.${funcName}() to fix the issue.`;\n    },\n    \"max-entries-or-age-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.maxEntries' or 'config.maxAgeSeconds' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"statuses-or-headers-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.statuses' or 'config.headers' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"invalid-string\": ({ moduleName, funcName, paramName })=>{\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${moduleName}.${funcName}() for more info.`;\n    },\n    \"channel-name-required\": ()=>{\n        return \"You must provide a channelName to construct a \" + \"BroadcastCacheUpdate instance.\";\n    },\n    \"invalid-responses-are-same-args\": ()=>{\n        return \"The arguments passed into responsesAreSame() appear to be \" + \"invalid. Please ensure valid Responses are used.\";\n    },\n    \"expire-custom-caches-only\": ()=>{\n        return `You must provide a 'cacheName' property when using the ` + \"expiration plugin with a runtime caching strategy.\";\n    },\n    \"unit-must-be-bytes\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"single-range-only\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"invalid-range-values\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"no-range-header\": ()=>{\n        return \"No Range header was found in the Request provided.\";\n    },\n    \"range-not-satisfiable\": ({ size, start, end })=>{\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n    },\n    \"attempt-to-cache-non-get-request\": ({ url, method })=>{\n        return `Unable to cache '${url}' because it is a '${method}' request and only 'GET' requests can be cached.`;\n    },\n    \"cache-put-with-no-response\": ({ url })=>{\n        return `There was an attempt to cache '${url}' but the response was not defined.`;\n    },\n    \"no-response\": ({ url, error })=>{\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    \"bad-precaching-response\": ({ url, status })=>{\n        return `The precaching request for '${url}' failed${status ? ` with an HTTP status of ${status}.` : \".\"}`;\n    },\n    \"non-precached-url\": ({ url })=>{\n        return `'createHandlerBoundToURL(\"${url}\")' was called, but that URL is not precached. Please pass in a URL that is precached instead.`;\n    },\n    \"add-to-cache-list-conflicting-integrities\": ({ url })=>{\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${url} with different integrity values. Please remove one of them.`;\n    },\n    \"missing-precache-entry\": ({ cacheName, url })=>{\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    \"cross-origin-copy-response\": ({ origin })=>{\n        return `'@serwist/core.copyResponse()' can only be used with same-origin responses. It was passed a response with origin ${origin}.`;\n    },\n    \"opaque-streams-source\": ({ type })=>{\n        const message = `One of the '@serwist/streams' sources resulted in an '${type}' response.`;\n        if (type === \"opaqueredirect\") {\n            return `${message} Please do not use a navigation request that results in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    }\n};\n\nconst fallback = (code, ...args)=>{\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {})=>{\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nconst messageGenerator = process.env.NODE_ENV === \"production\" ? fallback : generatorFunction;\n\nclass SerwistError extends Error {\n    details;\n    constructor(errorCode, details){\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\n\nconst isArray = (value, details)=>{\n    if (!Array.isArray(value)) {\n        throw new SerwistError(\"not-an-array\", details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details)=>{\n    const type = typeof object[expectedMethod];\n    if (type !== \"function\") {\n        details.expectedMethod = expectedMethod;\n        throw new SerwistError(\"missing-a-method\", details);\n    }\n};\nconst isType = (object, expectedType, details)=>{\n    if (typeof object !== expectedType) {\n        details.expectedType = expectedType;\n        throw new SerwistError(\"incorrect-type\", details);\n    }\n};\nconst isInstance = (object, expectedClass, details)=>{\n    if (!(object instanceof expectedClass)) {\n        details.expectedClassName = expectedClass.name;\n        throw new SerwistError(\"incorrect-class\", details);\n    }\n};\nconst isOneOf = (value, validValues, details)=>{\n    if (!validValues.includes(value)) {\n        details.validValueDescription = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new SerwistError(\"invalid-value\", details);\n    }\n};\nconst isArrayOfClass = (value, expectedClass, details)=>{\n    const error = new SerwistError(\"not-array-of-class\", details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value){\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports = process.env.NODE_ENV === \"production\" ? null : {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isType,\n    isArrayOfClass\n};\n\nconst logger = process.env.NODE_ENV === \"production\" || typeof self === \"undefined\" ? null : (()=>{\n    if (!(\"__WB_DISABLE_DEV_LOGS\" in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n    }\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: \"#7f8c8d\",\n        log: \"#2ecc71\",\n        warn: \"#f39c12\",\n        error: \"#c0392b\",\n        groupCollapsed: \"#3498db\",\n        groupEnd: null\n    };\n    const print = (method, args)=>{\n        if (self.__WB_DISABLE_DEV_LOGS) {\n            return;\n        }\n        if (method === \"groupCollapsed\") {\n            if (typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            \"border-radius: 0.5em\",\n            \"color: white\",\n            \"font-weight: bold\",\n            \"padding: 2px 0.5em\"\n        ];\n        const logPrefix = inGroup ? [] : [\n            \"%cserwist\",\n            styles.join(\";\")\n        ];\n        console[method](...logPrefix, ...args);\n        if (method === \"groupCollapsed\") {\n            inGroup = true;\n        }\n        if (method === \"groupEnd\") {\n            inGroup = false;\n        }\n    };\n    const loggerMethods = Object.keys(methodToColorMap);\n    return loggerMethods.reduce((api, method)=>{\n        api[method] = (...args)=>{\n            print(method, args);\n        };\n        return api;\n    }, {});\n})();\n\nconst getFriendlyURL = (url)=>{\n    const urlObj = new URL(String(url), location.href);\n    return urlObj.href.replace(new RegExp(`^${location.origin}`), \"\");\n};\n\nconst _cacheNameDetails = {\n    googleAnalytics: \"googleAnalytics\",\n    precache: \"precache-v2\",\n    prefix: \"serwist\",\n    runtime: \"runtime\",\n    suffix: typeof registration !== \"undefined\" ? registration.scope : \"\"\n};\nconst _createCacheName = (cacheName)=>{\n    return [\n        _cacheNameDetails.prefix,\n        cacheName,\n        _cacheNameDetails.suffix\n    ].filter((value)=>value && value.length > 0).join(\"-\");\n};\nconst eachCacheNameDetail = (fn)=>{\n    for (const key of Object.keys(_cacheNameDetails)){\n        fn(key);\n    }\n};\nconst cacheNames = {\n    updateDetails: (details)=>{\n        eachCacheNameDetail((key)=>{\n            const detail = details[key];\n            if (typeof detail === \"string\") {\n                _cacheNameDetails[key] = detail;\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: ()=>{\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: ()=>{\n        return _cacheNameDetails.suffix;\n    }\n};\n\nclass Deferred {\n    promise;\n    resolve;\n    reject;\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nfunction stripParams(fullURL, ignoreParams) {\n    const strippedURL = new URL(fullURL);\n    for (const param of ignoreParams){\n        strippedURL.searchParams.delete(param);\n    }\n    return strippedURL.href;\n}\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n    const strippedRequestURL = stripParams(request.url, ignoreParams);\n    if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n    }\n    const keysOptions = {\n        ...matchOptions,\n        ignoreSearch: true\n    };\n    const cacheKeys = await cache.keys(request, keysOptions);\n    for (const cacheKey of cacheKeys){\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n            return cache.match(cacheKey, matchOptions);\n        }\n    }\n    return;\n}\n\nconst quotaErrorCallbacks = new Set();\n\nconst executeQuotaErrorCallbacks = async ()=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        logger.log(`About to run ${quotaErrorCallbacks.size} callbacks to clean up caches.`);\n    }\n    for (const callback of quotaErrorCallbacks){\n        await callback();\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(callback, \"is complete.\");\n        }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n        logger.log(\"Finished running callbacks.\");\n    }\n};\n\nfunction timeout(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n\nlet supportStatus;\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response(\"\");\n        if (\"body\" in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            } catch  {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\n\nconst SUBSTRING_TO_FIND = \"-precache-\";\nconst deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND)=>{\n    const cacheNames = await self.caches.keys();\n    const cacheNamesToDelete = cacheNames.filter((cacheName)=>{\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n    });\n    await Promise.all(cacheNamesToDelete.map((cacheName)=>self.caches.delete(cacheName)));\n    return cacheNamesToDelete;\n};\n\nconst cleanupOutdatedCaches = (cacheName)=>{\n    self.addEventListener(\"activate\", (event)=>{\n        event.waitUntil(deleteOutdatedCaches(cacheNames.getPrecacheName(cacheName)).then((cachesDeleted)=>{\n            if (process.env.NODE_ENV !== \"production\") {\n                if (cachesDeleted.length > 0) {\n                    logger.log(\"The following out-of-date precaches were cleaned up automatically:\", cachesDeleted);\n                }\n            }\n        }));\n    });\n};\n\nconst clientsClaim = ()=>{\n    self.addEventListener(\"activate\", ()=>self.clients.claim());\n};\n\nconst waitUntil = (event, asyncFn)=>{\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n};\n\nexport { Deferred as D, SerwistError as S, clientsClaim as a, cleanupOutdatedCaches as b, cacheNames as c, cacheMatchIgnoreParams as d, executeQuotaErrorCallbacks as e, finalAssertExports as f, getFriendlyURL as g, canConstructResponseFromBodyStream as h, logger as l, quotaErrorCallbacks as q, timeout as t, waitUntil as w };\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import { f as finalAssertExports, l as logger, D as Deferred, S as SerwistError, g as getFriendlyURL, t as timeout, d as cacheMatchIgnoreParams, e as executeQuotaErrorCallbacks, c as cacheNames, h as canConstructResponseFromBodyStream } from './waitUntil.js';\nimport { openDB } from 'idb';\n\nconst defaultMethod = \"GET\";\nconst validMethods = [\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\"\n];\n\nconst normalizeHandler = (handler)=>{\n    if (handler && typeof handler === \"object\") {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.hasMethod(handler, \"handle\", {\n                moduleName: \"serwist\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"handler\"\n            });\n        }\n        return handler;\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n        finalAssertExports.isType(handler, \"function\", {\n            moduleName: \"serwist\",\n            className: \"Route\",\n            funcName: \"constructor\",\n            paramName: \"handler\"\n        });\n    }\n    return {\n        handle: handler\n    };\n};\n\nclass Route {\n    handler;\n    match;\n    method;\n    catchHandler;\n    constructor(match, handler, method = defaultMethod){\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(match, \"function\", {\n                moduleName: \"serwist\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"match\"\n            });\n            if (method) {\n                finalAssertExports.isOneOf(method, validMethods, {\n                    paramName: \"method\"\n                });\n            }\n        }\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n    setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n    }\n}\n\nclass NavigationRoute extends Route {\n    _allowlist;\n    _denylist;\n    constructor(handler, { allowlist = [\n        /./\n    ], denylist = [] } = {}){\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isArrayOfClass(allowlist, RegExp, {\n                moduleName: \"serwist\",\n                className: \"NavigationRoute\",\n                funcName: \"constructor\",\n                paramName: \"options.allowlist\"\n            });\n            finalAssertExports.isArrayOfClass(denylist, RegExp, {\n                moduleName: \"serwist\",\n                className: \"NavigationRoute\",\n                funcName: \"constructor\",\n                paramName: \"options.denylist\"\n            });\n        }\n        super((options)=>this._match(options), handler);\n        this._allowlist = allowlist;\n        this._denylist = denylist;\n    }\n    _match({ url, request }) {\n        if (request && request.mode !== \"navigate\") {\n            return false;\n        }\n        const pathnameAndSearch = url.pathname + url.search;\n        for (const regExp of this._denylist){\n            if (regExp.test(pathnameAndSearch)) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(`The navigation route ${pathnameAndSearch} is not being used, since the URL matches this denylist pattern: ${regExp.toString()}`);\n                }\n                return false;\n            }\n        }\n        if (this._allowlist.some((regExp)=>regExp.test(pathnameAndSearch))) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(`The navigation route ${pathnameAndSearch} is being used.`);\n            }\n            return true;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(`The navigation route ${pathnameAndSearch} is not being used, since the URL being navigated to doesn't match the allowlist.`);\n        }\n        return false;\n    }\n}\n\nconst removeIgnoredSearchParams = (urlObject, ignoreURLParametersMatching = [])=>{\n    for (const paramName of [\n        ...urlObject.searchParams.keys()\n    ]){\n        if (ignoreURLParametersMatching.some((regExp)=>regExp.test(paramName))) {\n            urlObject.searchParams.delete(paramName);\n        }\n    }\n    return urlObject;\n};\n\nfunction* generateURLVariations(url, { directoryIndex = \"index.html\", ignoreURLParametersMatching = [\n    /^utm_/,\n    /^fbclid$/\n], cleanURLs = true, urlManipulation } = {}) {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = \"\";\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith(\"/\")) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n    }\n    if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += \".html\";\n        yield cleanURL.href;\n    }\n    if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n            url: urlObject\n        });\n        for (const urlToAttempt of additionalURLs){\n            yield urlToAttempt.href;\n        }\n    }\n}\n\nclass RegExpRoute extends Route {\n    constructor(regExp, handler, method){\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(regExp, RegExp, {\n                moduleName: \"serwist\",\n                className: \"RegExpRoute\",\n                funcName: \"constructor\",\n                paramName: \"pattern\"\n            });\n        }\n        const match = ({ url })=>{\n            const result = regExp.exec(url.href);\n            if (!result) {\n                return;\n            }\n            if (url.origin !== location.origin && result.index !== 0) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.debug(`The regular expression '${regExp.toString()}' only partially matched against the cross-origin URL '${url.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\n\nconst parallel = async (limit, array, func)=>{\n    const work = array.map((item, index)=>({\n            index,\n            item\n        }));\n    const processor = async (res)=>{\n        const results = [];\n        while(true){\n            const next = work.pop();\n            if (!next) {\n                return res(results);\n            }\n            const result = await func(next.item);\n            results.push({\n                result: result,\n                index: next.index\n            });\n        }\n    };\n    const queues = Array.from({\n        length: limit\n    }, ()=>new Promise(processor));\n    const results = (await Promise.all(queues)).flat().sort((a, b)=>a.index < b.index ? -1 : 1).map((res)=>res.result);\n    return results;\n};\n\nconst disableDevLogs = ()=>{\n    self.__WB_DISABLE_DEV_LOGS = true;\n};\n\nfunction toRequest(input) {\n    return typeof input === \"string\" ? new Request(input) : input;\n}\nclass StrategyHandler {\n    event;\n    request;\n    url;\n    params;\n    _cacheKeys = {};\n    _strategy;\n    _handlerDeferred;\n    _extendLifetimePromises;\n    _plugins;\n    _pluginStateMap;\n    constructor(strategy, options){\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(options.event, ExtendableEvent, {\n                moduleName: \"serwist\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.event\"\n            });\n            finalAssertExports.isInstance(options.request, Request, {\n                moduleName: \"serwist\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.request\"\n            });\n        }\n        this.event = options.event;\n        this.request = options.request;\n        if (options.url) {\n            this.url = options.url;\n            this.params = options.params;\n        }\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        this._plugins = [\n            ...strategy.plugins\n        ];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins){\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        const preloadResponse = await this.getPreloadResponse();\n        if (preloadResponse) {\n            return preloadResponse;\n        }\n        const originalRequest = this.hasCallback(\"fetchDidFail\") ? request.clone() : null;\n        try {\n            for (const cb of this.iterateCallbacks(\"requestWillFetch\")){\n                request = await cb({\n                    request: request.clone(),\n                    event\n                });\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                throw new SerwistError(\"plugin-error-request-will-fetch\", {\n                    thrownErrorMessage: err.message\n                });\n            }\n        }\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            fetchResponse = await fetch(request, request.mode === \"navigate\" ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(`Network request for '${getFriendlyURL(request.url)}' returned a response with status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks(\"fetchDidSucceed\")){\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse\n                });\n            }\n            return fetchResponse;\n        } catch (error) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.log(`Network request for '${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            if (originalRequest) {\n                await this.runCallbacks(\"fetchDidFail\", {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone()\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, \"read\");\n        const multiMatchOptions = {\n            ...matchOptions,\n            ...{\n                cacheName\n            }\n        };\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== \"production\") {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            } else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cachedResponseWillBeUsed\")){\n            cachedResponse = await callback({\n                cacheName,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n                event: this.event\n            }) || undefined;\n        }\n        return cachedResponse;\n    }\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, \"write\");\n        if (process.env.NODE_ENV !== \"production\") {\n            if (effectiveRequest.method && effectiveRequest.method !== \"GET\") {\n                throw new SerwistError(\"attempt-to-cache-non-get-request\", {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method\n                });\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.error(`Cannot cache non-existent response for '${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new SerwistError(\"cache-put-with-no-response\", {\n                url: getFriendlyURL(effectiveRequest.url)\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        if (process.env.NODE_ENV !== \"production\") {\n            const vary = response.headers.get(\"Vary\");\n            if (vary && matchOptions?.ignoreVary !== true) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} has a 'Vary: ${vary}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        const hasCacheUpdateCallback = this.hasCallback(\"cacheDidUpdate\");\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(cache, effectiveRequest.clone(), [\n            \"__WB_REVISION__\"\n        ], matchOptions) : null;\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n            if (error instanceof Error) {\n                if (error.name === \"QuotaExceededError\") {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cacheDidUpdate\")){\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event\n            });\n        }\n        return true;\n    }\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks(\"cacheKeyWillBeUsed\")){\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    params: this.params\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins){\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)){\n            await callback(param);\n        }\n    }\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins){\n            if (typeof plugin[name] === \"function\") {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param)=>{\n                    const statefulParam = {\n                        ...param,\n                        state\n                    };\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    async doneWaiting() {\n        let promise;\n        while(promise = this._extendLifetimePromises.shift()){\n            await promise;\n        }\n    }\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    async getPreloadResponse() {\n        if (this.event instanceof FetchEvent && this.event.request.mode === \"navigate\" && \"preloadResponse\" in this.event) {\n            try {\n                const possiblePreloadResponse = await this.event.preloadResponse;\n                if (possiblePreloadResponse) {\n                    if (process.env.NODE_ENV !== \"production\") {\n                        logger.log(`Using a preloaded navigation response for '${getFriendlyURL(this.event.request.url)}'`);\n                    }\n                    return possiblePreloadResponse;\n                }\n            } catch (error) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.error(error);\n                }\n                return undefined;\n            }\n        }\n        return undefined;\n    }\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks(\"cacheWillUpdate\")){\n            responseToCache = await callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event\n            }) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`);\n                    } else {\n                        logger.debug(`The response for '${this.request.url}' returned a status code of '${response.status}' and won't be cached as a result.`);\n                    }\n                }\n                responseToCache = undefined;\n            }\n        }\n        return responseToCache;\n    }\n}\n\nclass Strategy {\n    cacheName;\n    plugins;\n    fetchOptions;\n    matchOptions;\n    constructor(options = {}){\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this.plugins = options.plugins || [];\n        this.fetchOptions = options.fetchOptions;\n        this.matchOptions = options.matchOptions;\n    }\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    handleAll(options) {\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === \"string\" ? new Request(options.request) : options.request;\n        const handler = new StrategyHandler(this, options.url ? {\n            event,\n            request,\n            url: options.url,\n            params: options.params\n        } : {\n            event,\n            request\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        return [\n            responseDone,\n            handlerDone\n        ];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks(\"handlerWillStart\", {\n            event,\n            request\n        });\n        let response;\n        try {\n            response = await this._handle(request, handler);\n            if (response === undefined || response.type === \"error\") {\n                throw new SerwistError(\"no-response\", {\n                    url: request.url\n                });\n            }\n        } catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks(\"handlerDidError\")){\n                    response = await callback({\n                        error,\n                        event,\n                        request\n                    });\n                    if (response !== undefined) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                throw logger.log(`While responding to '${getFriendlyURL(request.url)}', an ${error instanceof Error ? error.toString() : \"\"} error occurred. Using a fallback response provided by a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks(\"handlerWillRespond\")){\n            response = await callback({\n                event,\n                request,\n                response\n            });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        } catch  {}\n        try {\n            await handler.runCallbacks(\"handlerDidRespond\", {\n                event,\n                request,\n                response\n            });\n            await handler.doneWaiting();\n        } catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks(\"handlerDidComplete\", {\n            event,\n            request,\n            response,\n            error\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\n\nconst cacheOkAndOpaquePlugin = {\n    cacheWillUpdate: async ({ response })=>{\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    }\n};\n\nconst messages = {\n    strategyStart: (strategyName, request)=>`Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: (response)=>{\n        if (response) {\n            logger.groupCollapsed(\"View the final response here.\");\n            logger.log(response || \"[No response returned]\");\n            logger.groupEnd();\n        }\n    }\n};\n\nclass NetworkFirst extends Strategy {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== \"production\") {\n            if (this._networkTimeoutSeconds) {\n                finalAssertExports.isType(this._networkTimeoutSeconds, \"number\", {\n                    moduleName: \"serwist\",\n                    className: this.constructor.name,\n                    funcName: \"constructor\",\n                    paramName: \"networkTimeoutSeconds\"\n                });\n            }\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"makeRequest\"\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({\n                request,\n                logs,\n                handler\n            });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async ()=>{\n            return await handler.waitUntil(Promise.race(promises)) || await networkPromise;\n        })());\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new SerwistError(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n    _getTimeoutPromise({ request, logs, handler }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve)=>{\n            const onNetworkTimeout = async ()=>{\n                if (process.env.NODE_ENV !== \"production\") {\n                    logs.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId\n        };\n    }\n    async _getNetworkPromise({ timeoutId, request, logs, handler }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        } catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            if (response) {\n                logs.push(\"Got response from network.\");\n            } else {\n                logs.push(\"Unable to get a response from the network. Will respond \" + \"with a cached response.\");\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (process.env.NODE_ENV !== \"production\") {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n                } else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\n\nclass NetworkOnly extends Strategy {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"_handle\",\n                paramName: \"request\"\n            });\n        }\n        let error;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request)\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`);\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(\"Got response from network.\");\n            } else {\n                logger.log(\"Unable to get a response from the network.\");\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new SerwistError(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\nconst BACKGROUND_SYNC_DB_VERSION = 3;\nconst BACKGROUND_SYNC_DB_NAME = \"serwist-background-sync\";\nconst REQUEST_OBJECT_STORE_NAME = \"requests\";\nconst QUEUE_NAME_INDEX = \"queueName\";\nclass BackgroundSyncQueueDb {\n    _db = null;\n    async addEntry(entry) {\n        const db = await this.getDb();\n        const tx = db.transaction(REQUEST_OBJECT_STORE_NAME, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.add(entry);\n        await tx.done;\n    }\n    async getFirstEntryId() {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.openCursor();\n        return cursor?.value.id;\n    }\n    async getAllEntriesByQueueName(queueName) {\n        const db = await this.getDb();\n        const results = await db.getAllFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n        return results ? results : [];\n    }\n    async getEntryCountByQueueName(queueName) {\n        const db = await this.getDb();\n        return db.countFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n    }\n    async deleteEntry(id) {\n        const db = await this.getDb();\n        await db.delete(REQUEST_OBJECT_STORE_NAME, id);\n    }\n    async getFirstEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"next\");\n    }\n    async getLastEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"prev\");\n    }\n    async getEndEntryFromIndex(query, direction) {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.index(QUEUE_NAME_INDEX).openCursor(query, direction);\n        return cursor?.value;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await openDB(BACKGROUND_SYNC_DB_NAME, BACKGROUND_SYNC_DB_VERSION, {\n                upgrade: this._upgradeDb\n            });\n        }\n        return this._db;\n    }\n    _upgradeDb(db, oldVersion) {\n        if (oldVersion > 0 && oldVersion < BACKGROUND_SYNC_DB_VERSION) {\n            if (db.objectStoreNames.contains(REQUEST_OBJECT_STORE_NAME)) {\n                db.deleteObjectStore(REQUEST_OBJECT_STORE_NAME);\n            }\n        }\n        const objStore = db.createObjectStore(REQUEST_OBJECT_STORE_NAME, {\n            autoIncrement: true,\n            keyPath: \"id\"\n        });\n        objStore.createIndex(QUEUE_NAME_INDEX, QUEUE_NAME_INDEX, {\n            unique: false\n        });\n    }\n}\n\nclass BackgroundSyncQueueStore {\n    _queueName;\n    _queueDb;\n    constructor(queueName){\n        this._queueName = queueName;\n        this._queueDb = new BackgroundSyncQueueDb();\n    }\n    async pushEntry(entry) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry\"\n            });\n            finalAssertExports.isType(entry.requestData, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        delete entry.id;\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async unshiftEntry(entry) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry\"\n            });\n            finalAssertExports.isType(entry.requestData, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        const firstId = await this._queueDb.getFirstEntryId();\n        if (firstId) {\n            entry.id = firstId - 1;\n        } else {\n            delete entry.id;\n        }\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async popEntry() {\n        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));\n    }\n    async shiftEntry() {\n        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));\n    }\n    async getAll() {\n        return await this._queueDb.getAllEntriesByQueueName(this._queueName);\n    }\n    async size() {\n        return await this._queueDb.getEntryCountByQueueName(this._queueName);\n    }\n    async deleteEntry(id) {\n        await this._queueDb.deleteEntry(id);\n    }\n    async _removeEntry(entry) {\n        if (entry) {\n            await this.deleteEntry(entry.id);\n        }\n        return entry;\n    }\n}\n\nconst serializableProperties = [\n    \"method\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"mode\",\n    \"credentials\",\n    \"cache\",\n    \"redirect\",\n    \"integrity\",\n    \"keepalive\"\n];\nclass StorableRequest {\n    _requestData;\n    static async fromRequest(request) {\n        const requestData = {\n            url: request.url,\n            headers: {}\n        };\n        if (request.method !== \"GET\") {\n            requestData.body = await request.clone().arrayBuffer();\n        }\n        request.headers.forEach((value, key)=>{\n            requestData.headers[key] = value;\n        });\n        for (const prop of serializableProperties){\n            if (request[prop] !== undefined) {\n                requestData[prop] = request[prop];\n            }\n        }\n        return new StorableRequest(requestData);\n    }\n    constructor(requestData){\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(requestData, \"object\", {\n                moduleName: \"serwist\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData\"\n            });\n            finalAssertExports.isType(requestData.url, \"string\", {\n                moduleName: \"serwist\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData.url\"\n            });\n        }\n        if (requestData.mode === \"navigate\") {\n            requestData.mode = \"same-origin\";\n        }\n        this._requestData = requestData;\n    }\n    toObject() {\n        const requestData = Object.assign({}, this._requestData);\n        requestData.headers = Object.assign({}, this._requestData.headers);\n        if (requestData.body) {\n            requestData.body = requestData.body.slice(0);\n        }\n        return requestData;\n    }\n    toRequest() {\n        return new Request(this._requestData.url, this._requestData);\n    }\n    clone() {\n        return new StorableRequest(this.toObject());\n    }\n}\n\nconst TAG_PREFIX = \"serwist-background-sync\";\nconst MAX_RETENTION_TIME = 60 * 24 * 7;\nconst queueNames = new Set();\nconst convertEntry = (queueStoreEntry)=>{\n    const queueEntry = {\n        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n        timestamp: queueStoreEntry.timestamp\n    };\n    if (queueStoreEntry.metadata) {\n        queueEntry.metadata = queueStoreEntry.metadata;\n    }\n    return queueEntry;\n};\nclass BackgroundSyncQueue {\n    _name;\n    _onSync;\n    _maxRetentionTime;\n    _queueStore;\n    _forceSyncFallback;\n    _syncInProgress = false;\n    _requestsAddedDuringSync = false;\n    constructor(name, { forceSyncFallback, onSync, maxRetentionTime } = {}){\n        if (queueNames.has(name)) {\n            throw new SerwistError(\"duplicate-queue-name\", {\n                name\n            });\n        }\n        queueNames.add(name);\n        this._name = name;\n        this._onSync = onSync || this.replayRequests;\n        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n        this._forceSyncFallback = Boolean(forceSyncFallback);\n        this._queueStore = new BackgroundSyncQueueStore(this._name);\n        this._addSyncListener();\n    }\n    get name() {\n        return this._name;\n    }\n    async pushRequest(entry) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry\"\n            });\n            finalAssertExports.isInstance(entry.request, Request, {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"push\");\n    }\n    async unshiftRequest(entry) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry\"\n            });\n            finalAssertExports.isInstance(entry.request, Request, {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"unshift\");\n    }\n    async popRequest() {\n        return this._removeRequest(\"pop\");\n    }\n    async shiftRequest() {\n        return this._removeRequest(\"shift\");\n    }\n    async getAll() {\n        const allEntries = await this._queueStore.getAll();\n        const now = Date.now();\n        const unexpiredEntries = [];\n        for (const entry of allEntries){\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                await this._queueStore.deleteEntry(entry.id);\n            } else {\n                unexpiredEntries.push(convertEntry(entry));\n            }\n        }\n        return unexpiredEntries;\n    }\n    async size() {\n        return await this._queueStore.size();\n    }\n    async _addRequest({ request, metadata, timestamp = Date.now() }, operation) {\n        const storableRequest = await StorableRequest.fromRequest(request.clone());\n        const entry = {\n            requestData: storableRequest.toObject(),\n            timestamp\n        };\n        if (metadata) {\n            entry.metadata = metadata;\n        }\n        switch(operation){\n            case \"push\":\n                await this._queueStore.pushEntry(entry);\n                break;\n            case \"unshift\":\n                await this._queueStore.unshiftEntry(entry);\n                break;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(`Request for '${getFriendlyURL(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n        }\n        if (this._syncInProgress) {\n            this._requestsAddedDuringSync = true;\n        } else {\n            await this.registerSync();\n        }\n    }\n    async _removeRequest(operation) {\n        const now = Date.now();\n        let entry;\n        switch(operation){\n            case \"pop\":\n                entry = await this._queueStore.popEntry();\n                break;\n            case \"shift\":\n                entry = await this._queueStore.shiftEntry();\n                break;\n        }\n        if (entry) {\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                return this._removeRequest(operation);\n            }\n            return convertEntry(entry);\n        }\n        return undefined;\n    }\n    async replayRequests() {\n        let entry;\n        while(entry = await this.shiftRequest()){\n            try {\n                await fetch(entry.request.clone());\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(`Request for '${getFriendlyURL(entry.request.url)}' ` + `has been replayed in queue '${this._name}'`);\n                }\n            } catch  {\n                await this.unshiftRequest(entry);\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(`Request for '${getFriendlyURL(entry.request.url)}' ` + `failed to replay, putting it back in queue '${this._name}'`);\n                }\n                throw new SerwistError(\"queue-replay-failed\", {\n                    name: this._name\n                });\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`);\n        }\n    }\n    async registerSync() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            try {\n                await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n            } catch (err) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n                }\n            }\n        }\n    }\n    _addSyncListener() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            self.addEventListener(\"sync\", (event)=>{\n                if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n                    if (process.env.NODE_ENV !== \"production\") {\n                        logger.log(`Background sync for tag '${event.tag}' has been received`);\n                    }\n                    const syncComplete = async ()=>{\n                        this._syncInProgress = true;\n                        let syncError;\n                        try {\n                            await this._onSync({\n                                queue: this\n                            });\n                        } catch (error) {\n                            if (error instanceof Error) {\n                                syncError = error;\n                                throw syncError;\n                            }\n                        } finally{\n                            if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                                await this.registerSync();\n                            }\n                            this._syncInProgress = false;\n                            this._requestsAddedDuringSync = false;\n                        }\n                    };\n                    event.waitUntil(syncComplete());\n                }\n            });\n        } else {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.log(\"Background sync replaying without background sync event\");\n            }\n            void this._onSync({\n                queue: this\n            });\n        }\n    }\n    static get _queueNames() {\n        return queueNames;\n    }\n}\n\nclass BackgroundSyncPlugin {\n    _queue;\n    constructor(name, options){\n        this._queue = new BackgroundSyncQueue(name, options);\n    }\n    async fetchDidFail({ request }) {\n        await this._queue.pushRequest({\n            request\n        });\n    }\n}\n\nconst copyResponse = async (response, modifier)=>{\n    let origin = null;\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new SerwistError(\"cross-origin-copy-response\", {\n            origin\n        });\n    }\n    const clonedResponse = response.clone();\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n    };\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n};\n\nclass PrecacheStrategy extends Strategy {\n    _fallbackToNetwork;\n    static defaultPrecacheCacheabilityPlugin = {\n        async cacheWillUpdate ({ response }) {\n            if (!response || response.status >= 400) {\n                return null;\n            }\n            return response;\n        }\n    };\n    static copyRedirectedCacheableResponsesPlugin = {\n        async cacheWillUpdate ({ response }) {\n            return response.redirected ? await copyResponse(response) : response;\n        }\n    };\n    constructor(options = {}){\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork !== false;\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    async _handle(request, handler) {\n        const preloadResponse = await handler.getPreloadResponse();\n        if (preloadResponse) {\n            return preloadResponse;\n        }\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        if (handler.event && handler.event.type === \"install\") {\n            return await this._handleInstall(request, handler);\n        }\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = handler.params || {};\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.warn(`The precached response for ${getFriendlyURL(request.url)} in ${this.cacheName} was not found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== \"no-cors\" ? integrityInRequest || integrityInManifest : undefined\n            }));\n            if (integrityInManifest && noIntegrityConflict && request.mode !== \"no-cors\") {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== \"production\") {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        } else {\n            throw new SerwistError(\"missing-precache-entry\", {\n                cacheName: this.cacheName,\n                url: request.url\n            });\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            const cacheKey = params.cacheKey || await handler.getCacheKey(request, \"read\");\n            logger.groupCollapsed(`Precaching is responding to: ${getFriendlyURL(request.url)}`);\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(\"View request details here.\");\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(\"View response details here.\");\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            throw new SerwistError(\"bad-precaching-response\", {\n                url: request.url,\n                status: response.status\n            });\n        }\n        return response;\n    }\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()){\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n    }\n}\n\nconst isNavigationPreloadSupported = ()=>{\n    return Boolean(self.registration?.navigationPreload);\n};\nconst enableNavigationPreload = (headerValue)=>{\n    if (isNavigationPreloadSupported()) {\n        self.addEventListener(\"activate\", (event)=>{\n            event.waitUntil(self.registration.navigationPreload.enable().then(()=>{\n                if (headerValue) {\n                    void self.registration.navigationPreload.setHeaderValue(headerValue);\n                }\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(\"Navigation preloading is enabled.\");\n                }\n            }));\n        });\n    } else {\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(\"Navigation preloading is not supported in this browser.\");\n        }\n    }\n};\nconst disableNavigationPreload = ()=>{\n    if (isNavigationPreloadSupported()) {\n        self.addEventListener(\"activate\", (event)=>{\n            event.waitUntil(self.registration.navigationPreload.disable().then(()=>{\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(\"Navigation preloading is disabled.\");\n                }\n            }));\n        });\n    } else {\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(\"Navigation preloading is not supported in this browser.\");\n        }\n    }\n};\n\nconst setCacheNameDetails = (details)=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        for (const key of Object.keys(details)){\n            finalAssertExports.isType(details[key], \"string\", {\n                moduleName: \"@serwist/core\",\n                funcName: \"setCacheNameDetails\",\n                paramName: `details.${key}`\n            });\n        }\n        if (details.precache?.length === 0) {\n            throw new SerwistError(\"invalid-cache-name\", {\n                cacheNameId: \"precache\",\n                value: details.precache\n            });\n        }\n        if (details.runtime?.length === 0) {\n            throw new SerwistError(\"invalid-cache-name\", {\n                cacheNameId: \"runtime\",\n                value: details.runtime\n            });\n        }\n        if (details.googleAnalytics?.length === 0) {\n            throw new SerwistError(\"invalid-cache-name\", {\n                cacheNameId: \"googleAnalytics\",\n                value: details.googleAnalytics\n            });\n        }\n    }\n    cacheNames.updateDetails(details);\n};\n\nclass PrecacheInstallReportPlugin {\n    updatedURLs = [];\n    notUpdatedURLs = [];\n    handlerWillStart = async ({ request, state })=>{\n        if (state) {\n            state.originalRequest = request;\n        }\n    };\n    cachedResponseWillBeUsed = async ({ event, state, cachedResponse })=>{\n        if (event.type === \"install\") {\n            if (state?.originalRequest && state.originalRequest instanceof Request) {\n                const url = state.originalRequest.url;\n                if (cachedResponse) {\n                    this.notUpdatedURLs.push(url);\n                } else {\n                    this.updatedURLs.push(url);\n                }\n            }\n        }\n        return cachedResponse;\n    };\n}\n\nconst REVISION_SEARCH_PARAM = \"__WB_REVISION__\";\nconst createCacheKey = (entry)=>{\n    if (!entry) {\n        throw new SerwistError(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (typeof entry === \"string\") {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new SerwistError(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n    };\n};\n\nconst parseRoute = (capture, handler, method)=>{\n    if (typeof capture === \"string\") {\n        const captureUrl = new URL(capture, location.href);\n        if (process.env.NODE_ENV !== \"production\") {\n            if (!(capture.startsWith(\"/\") || capture.startsWith(\"http\"))) {\n                throw new SerwistError(\"invalid-string\", {\n                    moduleName: \"serwist\",\n                    funcName: \"parseRoute\",\n                    paramName: \"capture\"\n                });\n            }\n            const valueToCheck = capture.startsWith(\"http\") ? captureUrl.pathname : capture;\n            const wildcards = \"[*:?+]\";\n            if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n                logger.debug(`The '$capture' parameter contains an Express-style wildcard character (${wildcards}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url })=>{\n            if (process.env.NODE_ENV !== \"production\") {\n                if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n                    logger.debug(`${capture} only partially matches the cross-origin URL ${url.toString()}. This route will only handle cross-origin requests if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        return new Route(matchCallback, handler, method);\n    }\n    if (capture instanceof RegExp) {\n        return new RegExpRoute(capture, handler, method);\n    }\n    if (typeof capture === \"function\") {\n        return new Route(capture, handler, method);\n    }\n    if (capture instanceof Route) {\n        return capture;\n    }\n    throw new SerwistError(\"unsupported-route-type\", {\n        moduleName: \"serwist\",\n        funcName: \"parseRoute\",\n        paramName: \"capture\"\n    });\n};\n\nconst logGroup = (groupTitle, deletedURLs)=>{\n    logger.groupCollapsed(groupTitle);\n    for (const url of deletedURLs){\n        logger.log(url);\n    }\n    logger.groupEnd();\n};\nconst printCleanupDetails = (deletedURLs)=>{\n    const deletionCount = deletedURLs.length;\n    if (deletionCount > 0) {\n        logger.groupCollapsed(`During precaching cleanup, ${deletionCount} cached request${deletionCount === 1 ? \" was\" : \"s were\"} deleted.`);\n        logGroup(\"Deleted Cache Requests\", deletedURLs);\n        logger.groupEnd();\n    }\n};\n\nfunction _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n        return;\n    }\n    logger.groupCollapsed(groupTitle);\n    for (const url of urls){\n        logger.log(url);\n    }\n    logger.groupEnd();\n}\nconst printInstallDetails = (urlsToPrecache, urlsAlreadyPrecached)=>{\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n    if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? \"\" : \"s\"}.`;\n        if (alreadyPrecachedCount > 0) {\n            message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? \" is\" : \"s are\"} already cached.`;\n        }\n        logger.groupCollapsed(message);\n        _nestedGroup(\"View newly precached URLs.\", urlsToPrecache);\n        _nestedGroup(\"View previously precached URLs.\", urlsAlreadyPrecached);\n        logger.groupEnd();\n    }\n};\n\nexport { BackgroundSyncPlugin as B, NetworkFirst as N, PrecacheStrategy as P, Route as R, Strategy as S, NetworkOnly as a, NavigationRoute as b, createCacheKey as c, disableDevLogs as d, enableNavigationPreload as e, defaultMethod as f, generateURLVariations as g, PrecacheInstallReportPlugin as h, parallel as i, printInstallDetails as j, printCleanupDetails as k, cacheOkAndOpaquePlugin as l, messages as m, normalizeHandler as n, copyResponse as o, parseRoute as p, disableNavigationPreload as q, isNavigationPreloadSupported as r, setCacheNameDetails as s, StrategyHandler as t, RegExpRoute as u, BackgroundSyncQueue as v, BackgroundSyncQueueStore as w, StorableRequest as x };\n","import { R as Route, g as generateURLVariations, B as BackgroundSyncPlugin, N as NetworkFirst, a as NetworkOnly, P as PrecacheStrategy, e as enableNavigationPreload, s as setCacheNameDetails, b as NavigationRoute, S as Strategy, d as disableDevLogs, c as createCacheKey, f as defaultMethod, n as normalizeHandler, p as parseRoute, h as PrecacheInstallReportPlugin, i as parallel, j as printInstallDetails, k as printCleanupDetails, m as messages, l as cacheOkAndOpaquePlugin } from './chunks/printInstallDetails.js';\nexport { v as BackgroundSyncQueue, w as BackgroundSyncQueueStore, u as RegExpRoute, x as StorableRequest, t as StrategyHandler, o as copyResponse, q as disableNavigationPreload, r as isNavigationPreloadSupported } from './chunks/printInstallDetails.js';\nimport { l as logger, g as getFriendlyURL, c as cacheNames$1, a as clientsClaim, b as cleanupOutdatedCaches, f as finalAssertExports, S as SerwistError, w as waitUntil, t as timeout, q as quotaErrorCallbacks } from './chunks/waitUntil.js';\nimport { r as resultingClientExists } from './chunks/resultingClientExists.js';\nimport { deleteDB, openDB } from 'idb';\n\nclass PrecacheRoute extends Route {\n    constructor(serwist, options){\n        const match = ({ request })=>{\n            const urlsToCacheKeys = serwist.getUrlsToPrecacheKeys();\n            for (const possibleURL of generateURLVariations(request.url, options)){\n                const cacheKey = urlsToCacheKeys.get(possibleURL);\n                if (cacheKey) {\n                    const integrity = serwist.getIntegrityForPrecacheKey(cacheKey);\n                    return {\n                        cacheKey,\n                        integrity\n                    };\n                }\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(`Precaching did not find a match for ${getFriendlyURL(request.url)}.`);\n            }\n            return;\n        };\n        super(match, serwist.precacheStrategy);\n    }\n}\n\nconst QUEUE_NAME = \"serwist-google-analytics\";\nconst MAX_RETENTION_TIME = 60 * 48;\nconst GOOGLE_ANALYTICS_HOST = \"www.google-analytics.com\";\nconst GTM_HOST = \"www.googletagmanager.com\";\nconst ANALYTICS_JS_PATH = \"/analytics.js\";\nconst GTAG_JS_PATH = \"/gtag/js\";\nconst GTM_JS_PATH = \"/gtm.js\";\nconst COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\nconst createOnSyncCallback = (config)=>{\n    return async ({ queue })=>{\n        let entry;\n        while(entry = await queue.shiftRequest()){\n            const { request, timestamp } = entry;\n            const url = new URL(request.url);\n            try {\n                const params = request.method === \"POST\" ? new URLSearchParams(await request.clone().text()) : url.searchParams;\n                const originalHitTime = timestamp - (Number(params.get(\"qt\")) || 0);\n                const queueTime = Date.now() - originalHitTime;\n                params.set(\"qt\", String(queueTime));\n                if (config.parameterOverrides) {\n                    for (const param of Object.keys(config.parameterOverrides)){\n                        const value = config.parameterOverrides[param];\n                        params.set(param, value);\n                    }\n                }\n                if (typeof config.hitFilter === \"function\") {\n                    config.hitFilter.call(null, params);\n                }\n                await fetch(new Request(url.origin + url.pathname, {\n                    body: params.toString(),\n                    method: \"POST\",\n                    mode: \"cors\",\n                    credentials: \"omit\",\n                    headers: {\n                        \"Content-Type\": \"text/plain\"\n                    }\n                }));\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(`Request for '${getFriendlyURL(url.href)}' has been replayed`);\n                }\n            } catch (err) {\n                await queue.unshiftRequest(entry);\n                if (process.env.NODE_ENV !== \"production\") {\n                    logger.log(`Request for '${getFriendlyURL(url.href)}' failed to replay, putting it back in the queue.`);\n                }\n                throw err;\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.log(\"All Google Analytics request successfully replayed; \" + \"the queue is now empty!\");\n        }\n    };\n};\nconst createCollectRoutes = (bgSyncPlugin)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n    const handler = new NetworkOnly({\n        plugins: [\n            bgSyncPlugin\n        ]\n    });\n    return [\n        new Route(match, handler, \"GET\"),\n        new Route(match, handler, \"POST\")\n    ];\n};\nconst createAnalyticsJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n    const handler = new NetworkFirst({\n        cacheName\n    });\n    return new Route(match, handler, \"GET\");\n};\nconst createGtagJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n    const handler = new NetworkFirst({\n        cacheName\n    });\n    return new Route(match, handler, \"GET\");\n};\nconst createGtmJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n    const handler = new NetworkFirst({\n        cacheName\n    });\n    return new Route(match, handler, \"GET\");\n};\nconst initializeGoogleAnalytics = ({ serwist, cacheName, ...options })=>{\n    const resolvedCacheName = cacheNames$1.getGoogleAnalyticsName(cacheName);\n    const bgSyncPlugin = new BackgroundSyncPlugin(QUEUE_NAME, {\n        maxRetentionTime: MAX_RETENTION_TIME,\n        onSync: createOnSyncCallback(options)\n    });\n    const routes = [\n        createGtmJsRoute(resolvedCacheName),\n        createAnalyticsJsRoute(resolvedCacheName),\n        createGtagJsRoute(resolvedCacheName),\n        ...createCollectRoutes(bgSyncPlugin)\n    ];\n    for (const route of routes){\n        serwist.registerRoute(route);\n    }\n};\n\nclass PrecacheFallbackPlugin {\n    _fallbackUrls;\n    _serwist;\n    constructor({ fallbackUrls, serwist }){\n        this._fallbackUrls = fallbackUrls;\n        this._serwist = serwist;\n    }\n    async handlerDidError(param) {\n        for (const fallback of this._fallbackUrls){\n            if (typeof fallback === \"string\") {\n                const fallbackResponse = await this._serwist.matchPrecache(fallback);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            } else if (fallback.matcher(param)) {\n                const fallbackResponse = await this._serwist.matchPrecache(fallback.url);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n\nclass PrecacheCacheKeyPlugin {\n    _precacheController;\n    constructor({ precacheController }){\n        this._precacheController = precacheController;\n    }\n    cacheKeyWillBeUsed = async ({ request, params })=>{\n        const cacheKey = params?.cacheKey || this._precacheController.getPrecacheKeyForUrl(request.url);\n        return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n        }) : request;\n    };\n}\n\nconst parsePrecacheOptions = (serwist, precacheOptions = {})=>{\n    const { cacheName: precacheCacheName, plugins: precachePlugins = [], fetchOptions: precacheFetchOptions, matchOptions: precacheMatchOptions, fallbackToNetwork: precacheFallbackToNetwork, directoryIndex: precacheDirectoryIndex, ignoreURLParametersMatching: precacheIgnoreUrls, cleanURLs: precacheCleanUrls, urlManipulation: precacheUrlManipulation, cleanupOutdatedCaches, concurrency = 10, navigateFallback, navigateFallbackAllowlist, navigateFallbackDenylist } = precacheOptions ?? {};\n    return {\n        precacheStrategyOptions: {\n            cacheName: cacheNames$1.getPrecacheName(precacheCacheName),\n            plugins: [\n                ...precachePlugins,\n                new PrecacheCacheKeyPlugin({\n                    precacheController: serwist\n                })\n            ],\n            fetchOptions: precacheFetchOptions,\n            matchOptions: precacheMatchOptions,\n            fallbackToNetwork: precacheFallbackToNetwork\n        },\n        precacheRouteOptions: {\n            directoryIndex: precacheDirectoryIndex,\n            ignoreURLParametersMatching: precacheIgnoreUrls,\n            cleanURLs: precacheCleanUrls,\n            urlManipulation: precacheUrlManipulation\n        },\n        precacheMiscOptions: {\n            cleanupOutdatedCaches,\n            concurrency,\n            navigateFallback,\n            navigateFallbackAllowlist,\n            navigateFallbackDenylist\n        }\n    };\n};\n\nclass Serwist {\n    _urlsToCacheKeys = new Map();\n    _urlsToCacheModes = new Map();\n    _cacheKeysToIntegrities = new Map();\n    _concurrentPrecaching;\n    _precacheStrategy;\n    _routes;\n    _defaultHandlerMap;\n    _catchHandler;\n    _requestRules;\n    constructor({ precacheEntries, precacheOptions, skipWaiting = false, importScripts, navigationPreload = false, cacheId, clientsClaim: clientsClaim$1 = false, runtimeCaching, offlineAnalyticsConfig, disableDevLogs: disableDevLogs$1 = false, fallbacks, requestRules } = {}){\n        const { precacheStrategyOptions, precacheRouteOptions, precacheMiscOptions } = parsePrecacheOptions(this, precacheOptions);\n        this._concurrentPrecaching = precacheMiscOptions.concurrency;\n        this._precacheStrategy = new PrecacheStrategy(precacheStrategyOptions);\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n        this._requestRules = requestRules;\n        this.handleInstall = this.handleInstall.bind(this);\n        this.handleActivate = this.handleActivate.bind(this);\n        this.handleFetch = this.handleFetch.bind(this);\n        this.handleCache = this.handleCache.bind(this);\n        if (!!importScripts && importScripts.length > 0) self.importScripts(...importScripts);\n        if (navigationPreload) enableNavigationPreload();\n        if (cacheId !== undefined) {\n            setCacheNameDetails({\n                prefix: cacheId\n            });\n        }\n        if (skipWaiting) {\n            self.skipWaiting();\n        } else {\n            self.addEventListener(\"message\", (event)=>{\n                if (event.data && event.data.type === \"SKIP_WAITING\") {\n                    self.skipWaiting();\n                }\n            });\n        }\n        if (clientsClaim$1) clientsClaim();\n        if (!!precacheEntries && precacheEntries.length > 0) {\n            this.addToPrecacheList(precacheEntries);\n        }\n        if (precacheMiscOptions.cleanupOutdatedCaches) {\n            cleanupOutdatedCaches(precacheStrategyOptions.cacheName);\n        }\n        this.registerRoute(new PrecacheRoute(this, precacheRouteOptions));\n        if (precacheMiscOptions.navigateFallback) {\n            this.registerRoute(new NavigationRoute(this.createHandlerBoundToUrl(precacheMiscOptions.navigateFallback), {\n                allowlist: precacheMiscOptions.navigateFallbackAllowlist,\n                denylist: precacheMiscOptions.navigateFallbackDenylist\n            }));\n        }\n        if (offlineAnalyticsConfig !== undefined) {\n            if (typeof offlineAnalyticsConfig === \"boolean\") {\n                offlineAnalyticsConfig && initializeGoogleAnalytics({\n                    serwist: this\n                });\n            } else {\n                initializeGoogleAnalytics({\n                    ...offlineAnalyticsConfig,\n                    serwist: this\n                });\n            }\n        }\n        if (runtimeCaching !== undefined) {\n            if (fallbacks !== undefined) {\n                const fallbackPlugin = new PrecacheFallbackPlugin({\n                    fallbackUrls: fallbacks.entries,\n                    serwist: this\n                });\n                runtimeCaching.forEach((cacheEntry)=>{\n                    if (cacheEntry.handler instanceof Strategy && !cacheEntry.handler.plugins.some((plugin)=>\"handlerDidError\" in plugin)) {\n                        cacheEntry.handler.plugins.push(fallbackPlugin);\n                    }\n                });\n            }\n            for (const entry of runtimeCaching){\n                this.registerCapture(entry.matcher, entry.handler, entry.method);\n            }\n        }\n        if (disableDevLogs$1) disableDevLogs();\n    }\n    get precacheStrategy() {\n        return this._precacheStrategy;\n    }\n    get routes() {\n        return this._routes;\n    }\n    addEventListeners() {\n        self.addEventListener(\"install\", this.handleInstall);\n        self.addEventListener(\"activate\", this.handleActivate);\n        self.addEventListener(\"fetch\", this.handleFetch);\n        self.addEventListener(\"message\", this.handleCache);\n    }\n    addToPrecacheList(entries) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isArray(entries, {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"addToCacheList\",\n                paramName: \"entries\"\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries){\n            if (typeof entry === \"string\") {\n                urlsToWarnAbout.push(entry);\n            } else if (entry && !entry.integrity && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== \"string\" && entry.revision ? \"reload\" : \"default\";\n            if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new SerwistError(\"add-to-cache-list-conflicting-entries\", {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey\n                });\n            }\n            if (typeof entry !== \"string\" && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new SerwistError(\"add-to-cache-list-conflicting-integrities\", {\n                        url\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n        }\n        if (urlsToWarnAbout.length > 0) {\n            const warningMessage = `Serwist is precaching URLs without revision info: ${urlsToWarnAbout.join(\", \")}\\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;\n            if (process.env.NODE_ENV === \"production\") {\n                console.warn(warningMessage);\n            } else {\n                logger.warn(warningMessage);\n            }\n        }\n    }\n    handleInstall(event) {\n        void this.registerRequestRules(event);\n        return waitUntil(event, async ()=>{\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.precacheStrategy.plugins.push(installReportPlugin);\n            await parallel(this._concurrentPrecaching, Array.from(this._urlsToCacheKeys.entries()), async ([url, cacheKey])=>{\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: \"same-origin\"\n                });\n                await Promise.all(this.precacheStrategy.handleAll({\n                    event,\n                    request,\n                    url: new URL(request.url),\n                    params: {\n                        cacheKey\n                    }\n                }));\n            });\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== \"production\") {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return {\n                updatedURLs,\n                notUpdatedURLs\n            };\n        });\n    }\n    async registerRequestRules(event) {\n        if (!this._requestRules) {\n            return;\n        }\n        if (!event?.addRoutes) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.warn(\"Request rules ignored as the Static Routing API is not supported in this browser. \" + \"See https://caniuse.com/mdn-api_installevent_addroutes for more information.\");\n            }\n            return;\n        }\n        try {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.warn(\"Request rules may not be supported in all browsers as the Static Routing API is experimental. \" + \"This feature allows bypassing the service worker for specific requests to improve performance. \" + \"See https://developer.mozilla.org/en-US/docs/Web/API/InstallEvent/addRoutes for more information.\");\n            }\n            await event.addRoutes(this._requestRules);\n            this._requestRules = undefined;\n        } catch (error) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.error(`Failed to register request rules: ${error instanceof Error ? error.message : String(error)}. ` + \"This may occur if the browser doesn't support the Static Routing API or if the request rules are invalid.\");\n            }\n            throw error;\n        }\n    }\n    handleActivate(event) {\n        return waitUntil(event, async ()=>{\n            const cache = await self.caches.open(this.precacheStrategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedCacheRequests = [];\n            for (const request of currentlyCachedRequests){\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedCacheRequests.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                printCleanupDetails(deletedCacheRequests);\n            }\n            return {\n                deletedCacheRequests\n            };\n        });\n    }\n    handleFetch(event) {\n        const { request } = event;\n        const responsePromise = this.handleRequest({\n            request,\n            event\n        });\n        if (responsePromise) {\n            event.respondWith(responsePromise);\n        }\n    }\n    handleCache(event) {\n        if (event.data && event.data.type === \"CACHE_URLS\") {\n            const { payload } = event.data;\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n            }\n            const requestPromises = Promise.all(payload.urlsToCache.map((entry)=>{\n                let request;\n                if (typeof entry === \"string\") {\n                    request = new Request(entry);\n                } else {\n                    request = new Request(...entry);\n                }\n                return this.handleRequest({\n                    request,\n                    event\n                });\n            }));\n            event.waitUntil(requestPromises);\n            if (event.ports?.[0]) {\n                void requestPromises.then(()=>event.ports[0].postMessage(true));\n            }\n        }\n    }\n    setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    registerCapture(capture, handler, method) {\n        const route = parseRoute(capture, handler, method);\n        this.registerRoute(route);\n        return route;\n    }\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(route, \"object\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            finalAssertExports.hasMethod(route, \"match\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            finalAssertExports.isType(route.handler, \"object\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            finalAssertExports.hasMethod(route.handler, \"handle\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route.handler\"\n            });\n            finalAssertExports.isType(route.method, \"string\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route.method\"\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        this._routes.get(route.method).push(route);\n    }\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new SerwistError(\"unregister-route-but-not-found-with-method\", {\n                method: route.method\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n            throw new SerwistError(\"unregister-route-route-not-registered\");\n        }\n    }\n    getUrlsToPrecacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    getPrecachedUrls() {\n        return [\n            ...this._urlsToCacheKeys.keys()\n        ];\n    }\n    getPrecacheKeyForUrl(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    getIntegrityForPrecacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getPrecacheKeyForUrl(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.precacheStrategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    createHandlerBoundToUrl(url) {\n        const cacheKey = this.getPrecacheKeyForUrl(url);\n        if (!cacheKey) {\n            throw new SerwistError(\"non-precached-url\", {\n                url\n            });\n        }\n        return (options)=>{\n            options.request = new Request(url);\n            options.params = {\n                cacheKey,\n                ...options.params\n            };\n            return this.precacheStrategy.handle(options);\n        };\n    }\n    handleRequest({ request, event }) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"handleRequest\",\n                paramName: \"options.request\"\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith(\"http\")) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(\"Router only supports URLs that start with 'http'.\");\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url\n        });\n        let handler = route?.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== \"production\") {\n            if (handler) {\n                debugMessages.push([\n                    \"Found a route to handle this request:\",\n                    route\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params\n                    ]);\n                }\n            }\n        }\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (process.env.NODE_ENV !== \"production\") {\n                debugMessages.push(`Failed to find a matching route. Falling back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            for (const msg of debugMessages){\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                } else {\n                    logger.log(msg);\n                }\n            }\n            logger.groupEnd();\n        }\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({\n                url,\n                request,\n                event,\n                params\n            });\n        } catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        const catchHandler = route?.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err)=>{\n                if (catchHandler) {\n                    if (process.env.NODE_ENV !== \"production\") {\n                        logger.groupCollapsed(`Error thrown when responding to:  ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                        logger.error(\"Error thrown by:\", route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({\n                            url,\n                            request,\n                            event,\n                            params\n                        });\n                    } catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (process.env.NODE_ENV !== \"production\") {\n                        logger.groupCollapsed(`Error thrown when responding to:  ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                        logger.error(\"Error thrown by:\", route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    return this._catchHandler.handle({\n                        url,\n                        request,\n                        event\n                    });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    findMatchingRoute({ url, sameOrigin, request, event }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes){\n            let params;\n            const matchResult = route.match({\n                url,\n                sameOrigin,\n                request,\n                event\n            });\n            if (matchResult) {\n                if (process.env.NODE_ENV !== \"production\") {\n                    if (matchResult instanceof Promise) {\n                        logger.warn(`While routing ${getFriendlyURL(url)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    params = undefined;\n                } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n                    params = undefined;\n                } else if (typeof matchResult === \"boolean\") {\n                    params = undefined;\n                }\n                return {\n                    route,\n                    params\n                };\n            }\n        }\n        return {};\n    }\n}\n\nconst cacheNames = {\n    get googleAnalytics () {\n        return cacheNames$1.getGoogleAnalyticsName();\n    },\n    get precache () {\n        return cacheNames$1.getPrecacheName();\n    },\n    get prefix () {\n        return cacheNames$1.getPrefix();\n    },\n    get runtime () {\n        return cacheNames$1.getRuntimeName();\n    },\n    get suffix () {\n        return cacheNames$1.getSuffix();\n    }\n};\n\nconst BROADCAST_UPDATE_MESSAGE_TYPE = \"CACHE_UPDATED\";\nconst BROADCAST_UPDATE_MESSAGE_META = \"serwist-broadcast-update\";\nconst BROADCAST_UPDATE_DEFAULT_NOTIFY = true;\nconst BROADCAST_UPDATE_DEFAULT_HEADERS = [\n    \"content-length\",\n    \"etag\",\n    \"last-modified\"\n];\n\nconst responsesAreSame = (firstResponse, secondResponse, headersToCheck)=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        if (!(firstResponse instanceof Response && secondResponse instanceof Response)) {\n            throw new SerwistError(\"invalid-responses-are-same-args\");\n        }\n    }\n    const atLeastOneHeaderAvailable = headersToCheck.some((header)=>{\n        return firstResponse.headers.has(header) && secondResponse.headers.has(header);\n    });\n    if (!atLeastOneHeaderAvailable) {\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.warn(\"Unable to determine where the response has been updated because none of the headers that would be checked are present.\");\n            logger.debug(\"Attempting to compare the following: \", firstResponse, secondResponse, headersToCheck);\n        }\n        return true;\n    }\n    return headersToCheck.every((header)=>{\n        const headerStateComparison = firstResponse.headers.has(header) === secondResponse.headers.has(header);\n        const headerValueComparison = firstResponse.headers.get(header) === secondResponse.headers.get(header);\n        return headerStateComparison && headerValueComparison;\n    });\n};\n\nconst isSafari = typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nconst defaultPayloadGenerator = (data)=>{\n    return {\n        cacheName: data.cacheName,\n        updatedURL: data.request.url\n    };\n};\nclass BroadcastCacheUpdate {\n    _headersToCheck;\n    _generatePayload;\n    _notifyAllClients;\n    constructor({ generatePayload, headersToCheck, notifyAllClients } = {}){\n        this._headersToCheck = headersToCheck || BROADCAST_UPDATE_DEFAULT_HEADERS;\n        this._generatePayload = generatePayload || defaultPayloadGenerator;\n        this._notifyAllClients = notifyAllClients ?? BROADCAST_UPDATE_DEFAULT_NOTIFY;\n    }\n    async notifyIfUpdated(options) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(options.cacheName, \"string\", {\n                moduleName: \"serwist\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"cacheName\"\n            });\n            finalAssertExports.isInstance(options.newResponse, Response, {\n                moduleName: \"serwist\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"newResponse\"\n            });\n            finalAssertExports.isInstance(options.request, Request, {\n                moduleName: \"serwist\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"request\"\n            });\n        }\n        if (!options.oldResponse) {\n            return;\n        }\n        if (!responsesAreSame(options.oldResponse, options.newResponse, this._headersToCheck)) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logger.log(\"Newer response found (and cached) for:\", options.request.url);\n            }\n            const messageData = {\n                type: BROADCAST_UPDATE_MESSAGE_TYPE,\n                meta: BROADCAST_UPDATE_MESSAGE_META,\n                payload: this._generatePayload(options)\n            };\n            if (options.request.mode === \"navigate\") {\n                let resultingClientId;\n                if (options.event instanceof FetchEvent) {\n                    resultingClientId = options.event.resultingClientId;\n                }\n                const resultingWin = await resultingClientExists(resultingClientId);\n                if (!resultingWin || isSafari) {\n                    await timeout(3500);\n                }\n            }\n            if (this._notifyAllClients) {\n                const windows = await self.clients.matchAll({\n                    type: \"window\"\n                });\n                for (const win of windows){\n                    win.postMessage(messageData);\n                }\n            } else {\n                if (options.event instanceof FetchEvent) {\n                    const client = await self.clients.get(options.event.clientId);\n                    client?.postMessage(messageData);\n                }\n            }\n        }\n    }\n}\n\nclass BroadcastUpdatePlugin {\n    _broadcastUpdate;\n    constructor(options){\n        this._broadcastUpdate = new BroadcastCacheUpdate(options);\n    }\n    cacheDidUpdate(options) {\n        void this._broadcastUpdate.notifyIfUpdated(options);\n    }\n}\n\nclass CacheableResponse {\n    _statuses;\n    _headers;\n    constructor(config = {}){\n        if (process.env.NODE_ENV !== \"production\") {\n            if (!(config.statuses || config.headers)) {\n                throw new SerwistError(\"statuses-or-headers-required\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.statuses) {\n                finalAssertExports.isArray(config.statuses, {\n                    moduleName: \"serwist\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\",\n                    paramName: \"config.statuses\"\n                });\n            }\n            if (config.headers) {\n                finalAssertExports.isType(config.headers, \"object\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\",\n                    paramName: \"config.headers\"\n                });\n            }\n        }\n        this._statuses = config.statuses;\n        if (config.headers) {\n            this._headers = new Headers(config.headers);\n        }\n    }\n    isResponseCacheable(response) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(response, Response, {\n                moduleName: \"serwist\",\n                className: \"CacheableResponse\",\n                funcName: \"isResponseCacheable\",\n                paramName: \"response\"\n            });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n            cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n            for (const [headerName, headerValue] of this._headers.entries()){\n                if (response.headers.get(headerName) !== headerValue) {\n                    cacheable = false;\n                    break;\n                }\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            if (!cacheable) {\n                logger.groupCollapsed(`The request for '${getFriendlyURL(response.url)}' returned a response that does not meet the criteria for being cached.`);\n                logger.groupCollapsed(\"View cacheability criteria here.\");\n                logger.log(`Cacheable statuses: ${JSON.stringify(this._statuses)}`);\n                logger.log(`Cacheable headers: ${JSON.stringify(this._headers, null, 2)}`);\n                logger.groupEnd();\n                const logFriendlyHeaders = {};\n                response.headers.forEach((value, key)=>{\n                    logFriendlyHeaders[key] = value;\n                });\n                logger.groupCollapsed(\"View response status and headers here.\");\n                logger.log(`Response status: ${response.status}`);\n                logger.log(`Response headers: ${JSON.stringify(logFriendlyHeaders, null, 2)}`);\n                logger.groupEnd();\n                logger.groupCollapsed(\"View full response details here.\");\n                logger.log(response.headers);\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n            }\n        }\n        return cacheable;\n    }\n}\n\nclass CacheableResponsePlugin {\n    _cacheableResponse;\n    constructor(config){\n        this._cacheableResponse = new CacheableResponse(config);\n    }\n    cacheWillUpdate = async ({ response })=>{\n        if (this._cacheableResponse.isResponseCacheable(response)) {\n            return response;\n        }\n        return null;\n    };\n}\n\nconst DB_NAME = \"serwist-expiration\";\nconst CACHE_OBJECT_STORE = \"cache-entries\";\nconst normalizeURL = (unNormalizedUrl)=>{\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = \"\";\n    return url.href;\n};\nclass CacheTimestampsModel {\n    _cacheName;\n    _db = null;\n    constructor(cacheName){\n        this._cacheName = cacheName;\n    }\n    _getId(url) {\n        return `${this._cacheName}|${normalizeURL(url)}`;\n    }\n    _upgradeDb(db) {\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n            keyPath: \"id\"\n        });\n        objStore.createIndex(\"cacheName\", \"cacheName\", {\n            unique: false\n        });\n        objStore.createIndex(\"timestamp\", \"timestamp\", {\n            unique: false\n        });\n    }\n    _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n            void deleteDB(this._cacheName);\n        }\n    }\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            id: this._getId(url),\n            cacheName: this._cacheName,\n            url,\n            timestamp\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.put(entry);\n        await tx.done;\n    }\n    async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry?.timestamp;\n    }\n    async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db.transaction(CACHE_OBJECT_STORE, \"readwrite\").store.index(\"timestamp\").openCursor(null, \"prev\");\n        const urlsDeleted = [];\n        let entriesNotDeletedCount = 0;\n        while(cursor){\n            const result = cursor.value;\n            if (result.cacheName === this._cacheName) {\n                if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n                    cursor.delete();\n                    urlsDeleted.push(result.url);\n                } else {\n                    entriesNotDeletedCount++;\n                }\n            }\n            cursor = await cursor.continue();\n        }\n        return urlsDeleted;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await openDB(DB_NAME, 1, {\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n            });\n        }\n        return this._db;\n    }\n}\n\nclass CacheExpiration {\n    _isRunning = false;\n    _rerunRequested = false;\n    _maxEntries;\n    _maxAgeSeconds;\n    _matchOptions;\n    _cacheName;\n    _timestampModel;\n    constructor(cacheName, config = {}){\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(cacheName, \"string\", {\n                moduleName: \"serwist\",\n                className: \"CacheExpiration\",\n                funcName: \"constructor\",\n                paramName: \"cacheName\"\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new SerwistError(\"max-entries-or-age-required\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.maxEntries) {\n                finalAssertExports.isType(config.maxEntries, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxEntries\"\n                });\n            }\n            if (config.maxAgeSeconds) {\n                finalAssertExports.isType(config.maxAgeSeconds, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeSeconds\"\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired){\n            await cache.delete(url, this._matchOptions);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? \"entry\" : \"entries\"} and removed ` + `${urlsExpired.length === 1 ? \"it\" : \"them\"} from the ` + `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? \"URL\" : \"URLs\"}:`);\n                for (const url of urlsExpired){\n                    logger.log(`    ${url}`);\n                }\n                logger.groupEnd();\n            } else {\n                logger.debug(\"Cache expiration ran and found no entries to remove.\");\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            void this.expireEntries();\n        }\n    }\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(url, \"string\", {\n                moduleName: \"serwist\",\n                className: \"CacheExpiration\",\n                funcName: \"updateTimestamp\",\n                paramName: \"url\"\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== \"production\") {\n                throw new SerwistError(\"expired-test-without-max-age\", {\n                    methodName: \"isURLExpired\",\n                    paramName: \"maxAgeSeconds\"\n                });\n            }\n            return false;\n        }\n        const timestamp = await this._timestampModel.getTimestamp(url);\n        const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n        return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n    async delete() {\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Number.POSITIVE_INFINITY);\n    }\n}\n\nconst registerQuotaErrorCallback = (callback)=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        finalAssertExports.isType(callback, \"function\", {\n            moduleName: \"@serwist/core\",\n            funcName: \"register\",\n            paramName: \"callback\"\n        });\n    }\n    quotaErrorCallbacks.add(callback);\n    if (process.env.NODE_ENV !== \"production\") {\n        logger.log(\"Registered a callback to respond to quota errors.\", callback);\n    }\n};\n\nclass ExpirationPlugin {\n    _config;\n    _cacheExpirations;\n    constructor(config = {}){\n        if (process.env.NODE_ENV !== \"production\") {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new SerwistError(\"max-entries-or-age-required\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.maxEntries) {\n                finalAssertExports.isType(config.maxEntries, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxEntries\"\n                });\n            }\n            if (config.maxAgeSeconds) {\n                finalAssertExports.isType(config.maxAgeSeconds, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeSeconds\"\n                });\n            }\n            if (config.maxAgeFrom) {\n                finalAssertExports.isType(config.maxAgeFrom, \"string\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeFrom\"\n                });\n            }\n        }\n        this._config = config;\n        this._cacheExpirations = new Map();\n        if (!this._config.maxAgeFrom) {\n            this._config.maxAgeFrom = \"last-fetched\";\n        }\n        if (this._config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata());\n        }\n    }\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames$1.getRuntimeName()) {\n            throw new SerwistError(\"expire-custom-caches-only\");\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    cachedResponseWillBeUsed({ event, cacheName, request, cachedResponse }) {\n        if (!cachedResponse) {\n            return null;\n        }\n        const isFresh = this._isResponseDateFresh(cachedResponse);\n        const cacheExpiration = this._getCacheExpiration(cacheName);\n        const isMaxAgeFromLastUsed = this._config.maxAgeFrom === \"last-used\";\n        const done = (async ()=>{\n            if (isMaxAgeFromLastUsed) {\n                await cacheExpiration.updateTimestamp(request.url);\n            }\n            await cacheExpiration.expireEntries();\n        })();\n        try {\n            event.waitUntil(done);\n        } catch  {\n            if (process.env.NODE_ENV !== \"production\") {\n                if (event instanceof FetchEvent) {\n                    logger.warn(`Unable to ensure service worker stays alive when updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\n                }\n            }\n        }\n        return isFresh ? cachedResponse : null;\n    }\n    _isResponseDateFresh(cachedResponse) {\n        const isMaxAgeFromLastUsed = this._config.maxAgeFrom === \"last-used\";\n        if (isMaxAgeFromLastUsed) {\n            return true;\n        }\n        const now = Date.now();\n        if (!this._config.maxAgeSeconds) {\n            return true;\n        }\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            return true;\n        }\n        return dateHeaderTimestamp >= now - this._config.maxAgeSeconds * 1000;\n    }\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has(\"date\")) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get(\"date\");\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        if (Number.isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    async cacheDidUpdate({ cacheName, request }) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isType(cacheName, \"string\", {\n                moduleName: \"serwist\",\n                className: \"Plugin\",\n                funcName: \"cacheDidUpdate\",\n                paramName: \"cacheName\"\n            });\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: \"Plugin\",\n                funcName: \"cacheDidUpdate\",\n                paramName: \"request\"\n            });\n        }\n        const cacheExpiration = this._getCacheExpiration(cacheName);\n        await cacheExpiration.updateTimestamp(request.url);\n        await cacheExpiration.expireEntries();\n    }\n    async deleteCacheAndMetadata() {\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations){\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        this._cacheExpirations = new Map();\n    }\n}\n\nconst calculateEffectiveBoundaries = (blob, start, end)=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        finalAssertExports.isInstance(blob, Blob, {\n            moduleName: \"@serwist/range-requests\",\n            funcName: \"calculateEffectiveBoundaries\",\n            paramName: \"blob\"\n        });\n    }\n    const blobSize = blob.size;\n    if (end && end > blobSize || start && start < 0) {\n        throw new SerwistError(\"range-not-satisfiable\", {\n            size: blobSize,\n            end,\n            start\n        });\n    }\n    let effectiveStart;\n    let effectiveEnd;\n    if (start !== undefined && end !== undefined) {\n        effectiveStart = start;\n        effectiveEnd = end + 1;\n    } else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n    } else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n    }\n    return {\n        start: effectiveStart,\n        end: effectiveEnd\n    };\n};\n\nconst parseRangeHeader = (rangeHeader)=>{\n    if (process.env.NODE_ENV !== \"production\") {\n        finalAssertExports.isType(rangeHeader, \"string\", {\n            moduleName: \"@serwist/range-requests\",\n            funcName: \"parseRangeHeader\",\n            paramName: \"rangeHeader\"\n        });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n    if (!normalizedRangeHeader.startsWith(\"bytes=\")) {\n        throw new SerwistError(\"unit-must-be-bytes\", {\n            normalizedRangeHeader\n        });\n    }\n    if (normalizedRangeHeader.includes(\",\")) {\n        throw new SerwistError(\"single-range-only\", {\n            normalizedRangeHeader\n        });\n    }\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n    if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new SerwistError(\"invalid-range-values\", {\n            normalizedRangeHeader\n        });\n    }\n    return {\n        start: rangeParts[1] === \"\" ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === \"\" ? undefined : Number(rangeParts[2])\n    };\n};\n\nconst createPartialResponse = async (request, originalResponse)=>{\n    try {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"@serwist/range-requests\",\n                funcName: \"createPartialResponse\",\n                paramName: \"request\"\n            });\n            finalAssertExports.isInstance(originalResponse, Response, {\n                moduleName: \"@serwist/range-requests\",\n                funcName: \"createPartialResponse\",\n                paramName: \"originalResponse\"\n            });\n        }\n        if (originalResponse.status === 206) {\n            return originalResponse;\n        }\n        const rangeHeader = request.headers.get(\"range\");\n        if (!rangeHeader) {\n            throw new SerwistError(\"no-range-header\");\n        }\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n            status: 206,\n            statusText: \"Partial Content\",\n            headers: originalResponse.headers\n        });\n        slicedResponse.headers.set(\"Content-Length\", String(slicedBlobSize));\n        slicedResponse.headers.set(\"Content-Range\", `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` + `${originalBlob.size}`);\n        return slicedResponse;\n    } catch (error) {\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.warn(\"Unable to construct a partial response; returning a \" + \"416 Range Not Satisfiable response instead.\");\n            logger.groupCollapsed(\"View details here.\");\n            logger.log(error);\n            logger.log(request);\n            logger.log(originalResponse);\n            logger.groupEnd();\n        }\n        return new Response(\"\", {\n            status: 416,\n            statusText: \"Range Not Satisfiable\"\n        });\n    }\n};\n\nclass RangeRequestsPlugin {\n    cachedResponseWillBeUsed = async ({ request, cachedResponse })=>{\n        if (cachedResponse && request.headers.has(\"range\")) {\n            return await createPartialResponse(request, cachedResponse);\n        }\n        return cachedResponse;\n    };\n}\n\nclass CacheFirst extends Strategy {\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"makeRequest\",\n                paramName: \"request\"\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (!response) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logs.push(`No response found in the '${this.cacheName}' cache. Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            } catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                if (response) {\n                    logs.push(\"Got response from network.\");\n                } else {\n                    logs.push(\"Unable to get a response from the network.\");\n                }\n            }\n        } else {\n            if (process.env.NODE_ENV !== \"production\") {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new SerwistError(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\nclass CacheOnly extends Strategy {\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"makeRequest\",\n                paramName: \"request\"\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this.cacheName}' cache.`);\n                messages.printFinalResponse(response);\n            } else {\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new SerwistError(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n}\n\nclass StaleWhileRevalidate extends Strategy {\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== \"production\") {\n            finalAssertExports.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"request\"\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(()=>{});\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== \"production\") {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache. Will update with the network response in the background.`);\n            }\n        } else {\n            if (process.env.NODE_ENV !== \"production\") {\n                logs.push(`No response found in the '${this.cacheName}' cache. Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            } catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new SerwistError(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\nexport { BROADCAST_UPDATE_DEFAULT_HEADERS, BackgroundSyncPlugin, BroadcastCacheUpdate, BroadcastUpdatePlugin, CacheExpiration, CacheFirst, CacheOnly, CacheableResponse, CacheableResponsePlugin, ExpirationPlugin, NavigationRoute, NetworkFirst, NetworkOnly, PrecacheFallbackPlugin, PrecacheRoute, PrecacheStrategy, RangeRequestsPlugin, Route, Serwist, StaleWhileRevalidate, Strategy, cacheNames, createPartialResponse, disableDevLogs, enableNavigationPreload, initializeGoogleAnalytics, registerQuotaErrorCallback, responsesAreSame, setCacheNameDetails };\n","export const SECOND = 1000;\nexport const MINUTE = 60 * SECOND;\nexport const HOUR = 60 * MINUTE;\nexport const DAY = 24 * HOUR;\nexport const WEEK = 7 * DAY;\nexport const MONTH = 29.53 * DAY;\nexport const YEAR = 365.2425 * DAY;\n\nexport const MAX_DATE = new Date(8.64e15);\nexport const EPOC = new Date(0);\n\nexport function midnight(date: Date = new Date()): Date {\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n}\n\nexport function roundToMinute(date: Date): Date {\n  return new Date(Math.round(date.getTime() / MINUTE) * MINUTE);\n}\n\nexport function today(): Date {\n  return midnight(new Date());\n}\n\nexport function nextWeek(): Date {\n  return new Date(midnight(new Date(Date.now() + WEEK)).getTime() - MINUTE);\n}\n\ntype FormatDurationParts = {\n  unit: Intl.RelativeTimeFormatUnit;\n  multiplier: number;\n  value: number;\n};\n\nexport function formatDurationParts(ms: number): FormatDurationParts {\n  const absMs = Math.abs(ms);\n\n  if (absMs < 1.5 * MINUTE) {\n    return {\n      unit: \"second\",\n      multiplier: SECOND,\n      value: ms / SECOND,\n    };\n  }\n\n  if (absMs < 1.5 * HOUR) {\n    return {\n      unit: \"minute\",\n      multiplier: MINUTE,\n      value: ms / MINUTE,\n    };\n  }\n\n  if (absMs < 1.5 * DAY) {\n    return {\n      unit: \"hour\",\n      multiplier: HOUR,\n      value: ms / HOUR,\n    };\n  }\n\n  if (absMs < WEEK) {\n    return {\n      unit: \"day\",\n      multiplier: DAY,\n      value: ms / DAY,\n    };\n  }\n\n  if (absMs < MONTH) {\n    return {\n      unit: \"week\",\n      multiplier: WEEK,\n      value: ms / WEEK,\n    };\n  }\n\n  if (absMs < YEAR) {\n    return {\n      unit: \"month\",\n      multiplier: MONTH,\n      value: ms / MONTH,\n    };\n  }\n\n  return {\n    unit: \"year\",\n    multiplier: YEAR,\n    value: ms / YEAR,\n  };\n}\n\nconst relativeTimeFormat = new Intl.RelativeTimeFormat(\"default\", {\n  numeric: \"always\",\n  style: \"short\",\n});\n\nexport function formatRelativeTime(ms: number): string {\n  const { unit, value } = formatDurationParts(ms);\n\n  return relativeTimeFormat.format(Math.round(value), unit);\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    globalThis.setTimeout(resolve, ms);\n  });\n}\n","import {\n  CacheFirst,\n  CacheWillUpdateCallbackParam,\n  ExpirationPlugin,\n  type PrecacheEntry,\n  Route,\n  Serwist,\n  type SerwistGlobalConfig,\n  SerwistPlugin,\n  StaleWhileRevalidate,\n} from \"serwist\";\n\nimport { MONTH } from \"./helpers/time.ts\";\n\ndeclare global {\n  interface WorkerGlobalScope extends SerwistGlobalConfig {\n    __SW_MANIFEST: (PrecacheEntry | string)[] | undefined;\n  }\n}\n\ndeclare const self: ServiceWorkerGlobalScope;\n\ntype CacheableResponsePluginOptions = {\n  statuses: number[];\n  headers: HeadersInit;\n};\n\nclass CacheableResponsePlugin implements SerwistPlugin {\n  #statuses: number[];\n  #headers?: Headers;\n\n  constructor({ statuses = [200], headers }: CacheableResponsePluginOptions) {\n    this.#statuses = statuses;\n\n    if (headers) {\n      this.#headers = new Headers(headers);\n    }\n  }\n\n  async cacheWillUpdate({\n    response,\n  }: CacheWillUpdateCallbackParam): Promise<Response | null> {\n    if (!this.#statuses.includes(response.status)) {\n      return null;\n    }\n\n    if (!this.#headers) {\n      return response;\n    }\n\n    for (const [key, value] of this.#headers) {\n      if (!response.headers.get(key)?.startsWith(value)) {\n        return null;\n      }\n    }\n\n    return response;\n  }\n}\n\nconst serwist = new Serwist({\n  precacheEntries: self.__SW_MANIFEST,\n  skipWaiting: true,\n  clientsClaim: true,\n  navigationPreload: true,\n});\n\nconst jsonHeaders = new Headers([[\"Content-Type\", \"application/json\"]]);\nconst svgHeaders = new Headers([[\"Content-Type\", \"image/svg+xml\"]]);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/index/\") &&\n      url.pathname.endsWith(\".usv\"),\n\n    new StaleWhileRevalidate({\n      cacheName: \"shodoku-data-index\",\n      plugins: [\n        new ExpirationPlugin({\n          maxAgeSeconds: MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 10,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/kanji-lists/\") &&\n      url.pathname.endsWith(\".csv\"),\n\n    new StaleWhileRevalidate({\n      cacheName: \"shodoku-data-kanji-lists\",\n      plugins: [\n        new ExpirationPlugin({\n          maxAgeSeconds: MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 100,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/component-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-components-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 500,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/kanji-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-kanji-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 2000,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/kana-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-kana-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/kanjivg/kanji/\") &&\n      url.pathname.endsWith(\".svg\"),\n    new CacheFirst({\n      cacheName: \"shodoku-kanjivg\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: svgHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 2000,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/words-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-words-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 5000,\n          purgeOnQuotaError: true,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/kanji-vocab-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-kanji-vocab-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 500,\n          purgeOnQuotaError: true,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/sentences-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-sentences-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 3000,\n          purgeOnQuotaError: true,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.registerRoute(\n  new Route(\n    ({ url, sameOrigin }) =>\n      sameOrigin &&\n      url.pathname.startsWith(\"/data/words-sentences-v1/\") &&\n      url.pathname.endsWith(\".json\"),\n\n    new CacheFirst({\n      cacheName: \"shodoku-data-words-sentences-v1\",\n      plugins: [\n        new CacheableResponsePlugin({\n          statuses: [0, 200],\n          headers: jsonHeaders,\n        }),\n        new ExpirationPlugin({\n          maxAgeSeconds: 3 * MONTH,\n          maxAgeFrom: \"last-used\",\n          maxEntries: 1000,\n          purgeOnQuotaError: true,\n        }),\n      ],\n    }),\n  ),\n);\n\nserwist.addEventListeners();\n"],"names":["fallback","code","args","msg","messageGenerator","SerwistError","errorCode","details","message","getFriendlyURL","url","_cacheNameDetails","_createCacheName","cacheName","value","eachCacheNameDetail","fn","key","cacheNames","detail","userCacheName","Deferred","resolve","reject","stripParams","fullURL","ignoreParams","strippedURL","param","cacheMatchIgnoreParams","cache","request","matchOptions","strippedRequestURL","keysOptions","cacheKeys","cacheKey","strippedCacheKeyURL","quotaErrorCallbacks","executeQuotaErrorCallbacks","callback","timeout","ms","supportStatus","canConstructResponseFromBodyStream","testResponse","SUBSTRING_TO_FIND","deleteOutdatedCaches","currentPrecacheName","substringToFind","cacheNamesToDelete","cleanupOutdatedCaches","event","cachesDeleted","clientsClaim","waitUntil","asyncFn","returnPromise","instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","transactionDoneMap","transformCache","reverseTransformCache","promisifyRequest","promise","unlisten","success","error","wrap","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","target","prop","receiver","replaceTraps","wrapFunction","func","unwrap","transformCachableValue","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","openPromise","db","deleteDB","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","proxiedCursor","isIteratorProp","defaultMethod","normalizeHandler","handler","Route","match","NavigationRoute","allowlist","denylist","options","pathnameAndSearch","regExp","removeIgnoredSearchParams","urlObject","ignoreURLParametersMatching","paramName","generateURLVariations","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","directoryURL","cleanURL","additionalURLs","urlToAttempt","RegExpRoute","result","parallel","limit","array","work","item","index","processor","res","results","next","queues","a","b","disableDevLogs","toRequest","input","StrategyHandler","strategy","plugin","preloadResponse","originalRequest","cb","err","pluginFilteredRequest","fetchResponse","response","responseClone","cachedResponse","effectiveRequest","multiMatchOptions","responseToCache","hasCacheUpdateCallback","oldResponse","mode","state","statefulParam","possiblePreloadResponse","pluginsUsed","Strategy","responseDone","handlerDone","waitUntilError","cacheOkAndOpaquePlugin","NetworkFirst","p","logs","promises","timeoutId","id","networkPromise","fetchError","NetworkOnly","timeoutPromise","BACKGROUND_SYNC_DB_VERSION","BACKGROUND_SYNC_DB_NAME","REQUEST_OBJECT_STORE_NAME","QUEUE_NAME_INDEX","BackgroundSyncQueueDb","entry","queueName","query","direction","oldVersion","BackgroundSyncQueueStore","firstId","serializableProperties","StorableRequest","requestData","TAG_PREFIX","MAX_RETENTION_TIME","queueNames","convertEntry","queueStoreEntry","queueEntry","BackgroundSyncQueue","forceSyncFallback","onSync","maxRetentionTime","allEntries","now","unexpiredEntries","maxRetentionTimeInMs","metadata","timestamp","operation","syncComplete","syncError","BackgroundSyncPlugin","copyResponse","modifier","origin","clonedResponse","modifiedResponseInit","body","PrecacheStrategy","params","integrityInManifest","integrityInRequest","noIntegrityConflict","defaultPluginIndex","cacheWillUpdatePluginCount","isNavigationPreloadSupported","enableNavigationPreload","headerValue","setCacheNameDetails","PrecacheInstallReportPlugin","REVISION_SEARCH_PARAM","createCacheKey","revision","cacheKeyURL","originalURL","parseRoute","capture","captureUrl","matchCallback","PrecacheRoute","serwist","urlsToCacheKeys","possibleURL","integrity","QUEUE_NAME","GOOGLE_ANALYTICS_HOST","GTM_HOST","ANALYTICS_JS_PATH","GTAG_JS_PATH","GTM_JS_PATH","COLLECT_PATHS_REGEX","createOnSyncCallback","config","queue","originalHitTime","queueTime","createCollectRoutes","bgSyncPlugin","createAnalyticsJsRoute","createGtagJsRoute","createGtmJsRoute","initializeGoogleAnalytics","resolvedCacheName","cacheNames$1","routes","route","PrecacheFallbackPlugin","fallbackUrls","fallbackResponse","PrecacheCacheKeyPlugin","precacheController","parsePrecacheOptions","precacheOptions","precacheCacheName","precachePlugins","precacheFetchOptions","precacheMatchOptions","precacheFallbackToNetwork","precacheDirectoryIndex","precacheIgnoreUrls","precacheCleanUrls","precacheUrlManipulation","concurrency","navigateFallback","navigateFallbackAllowlist","navigateFallbackDenylist","Serwist","precacheEntries","skipWaiting","importScripts","navigationPreload","cacheId","clientsClaim$1","runtimeCaching","offlineAnalyticsConfig","disableDevLogs$1","fallbacks","requestRules","precacheStrategyOptions","precacheRouteOptions","precacheMiscOptions","fallbackPlugin","cacheEntry","entries","urlsToWarnAbout","cacheMode","warningMessage","installReportPlugin","updatedURLs","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","deletedCacheRequests","responsePromise","payload","requestPromises","routeIndex","sameOrigin","catchHandler","catchErr","matchResult","DB_NAME","CACHE_OBJECT_STORE","normalizeURL","unNormalizedUrl","CacheTimestampsModel","objStore","minTimestamp","maxCount","urlsDeleted","entriesNotDeletedCount","CacheExpiration","urlsExpired","expireOlderThan","registerQuotaErrorCallback","ExpirationPlugin","cacheExpiration","isFresh","isMaxAgeFromLastUsed","dateHeaderTimestamp","dateHeader","headerTime","CacheFirst","StaleWhileRevalidate","fetchAndCachePromise","SECOND","MINUTE","HOUR","DAY","MONTH","CacheableResponsePlugin","#statuses","#headers","statuses","headers","define_self_SW_MANIFEST_default","jsonHeaders","svgHeaders"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}